[{"title":"SpringMVC","date":"2021-12-20T20:07:38.421Z","date_formatted":{"ll":"2021年12月20日","L":"2021/12/20","MM-DD":"12-20"},"updated":"2021-12-20T12:19:12.680Z","content":"Spring MVC\n入门\n概述\nSpring MVC是Spring提供的一个 实现了Web MVC设计模式的 轻量级Web框架。 Spring MVC具有如下特点 :\n\n支持国际化。\n支持多种视图技术。\n灵活性强，易于与其它框架集成。\n内置常见效验器，可以效验用户输入。\n可自动绑定用户输入，并正确的转换数据类型。\n使用基于XML的配置文件，编写后无需重新编译应用程序。\n提供了一个前端控制器DispatcherServlet，使开发人员无须额外开发控制器对象。\n…\n\nDispatcherServlet\nSpring MVC 框架围绕DispatcherServlet 设计。DispatcherServlet 的作用是将请求分发到不同的处理器。\n从Spring 2.5开始，使用Java 5 及以上版本的用户可以采用基于注解的Controller 声明方式。\nSpring MVC 框架像许多其他MVC 框架一样，以请求为驱动 ，围绕一个中心Servlet分派请求及提供其他功能。\nDispatcherServlet其本质是一个符合J2EE规范的标准Servler (它继承自HttpServlet 基类)。\n工作流程\n123456789101112SpringMVC 工作流程：01、用户发送出请求到前端控制器DispatcherServlet。02、DispatcherServlet收到请求调用HandlerMapping（处理器映射器）。03、HandlerMapping找到具体的处理器(可查找xml配置或注解配置)，生成处理器对象及处理器拦截器(如果有)，再一起返回给DispatcherServlet。04、DispatcherServlet调用HandlerAdapter（处理器适配器）。05、HandlerAdapter经过适配调用具体的处理器（Handler/Controller）。06、Controller执行完成返回ModelAndView对象。07、HandlerAdapter将Controller执行结果ModelAndView返回给DispatcherServlet。08、DispatcherServlet将ModelAndView传给ViewReslover（视图解析器）。09、ViewReslover解析后返回具体View（视图）。10、DispatcherServlet根据View进行渲染视图（即将模型数据填充至视图中）。11、DispatcherServlet响应用户。\n如图所示：\n\n图自：https://github.com/YUbuntu0109/YUbuntu0109.github.io/blob/HexoBackup/source/_posts/Hi-SpringMVC.md\nSpring MVC 运行时序图可参考：\n\nhttps://www.processon.com/view/5e7376c2e4b03b99652516aa\nhttps://blog.csdn.net/programme_girl/article/details/78241360\n\nHello World\n普通Servlet版\n先用以前的方式写一个Hello World，回顾一下并方便对比区别。\nIDEA 新建一个 Module。\n然后添加Web 支持，这时会在项目模块内多出一个Web 文件夹：\n\n注：通过 添加框架支持-Web 应用，这种方式生成的Web 文件夹，可能缺少lib子文件夹。会导致依赖包没有导出，报404。\n解决方法：\n\n接着引入依赖，可以引入到父工程，方便子工程继承：\n12345678910111213141516&lt;!--Servlet、JSP、JSTL 所需依赖--&gt;&lt;dependency&gt;    &lt;groupId&gt;javax.servlet&lt;/groupId&gt;    &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;    &lt;version&gt;4.0.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt;    &lt;artifactId&gt;jsp-api&lt;/artifactId&gt;    &lt;version&gt;2.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;javax.servlet&lt;/groupId&gt;    &lt;artifactId&gt;jstl&lt;/artifactId&gt;    &lt;version&gt;1.2&lt;/version&gt;&lt;/dependency&gt;\n新建Servlet com.chenyuxi.servlet.TestServlet\n123456789101112@WebServlet(value = &quot;/hello&quot;)public class TestServlet extends HttpServlet &#123;    @Override    protected void doPost(HttpServletRequest request， HttpServletResponse response) throws ServletException， IOException &#123;        this.doGet(request，response);    &#125;    @Override    protected void doGet(HttpServletRequest request， HttpServletResponse response) throws ServletException， IOException &#123;        request.getRequestDispatcher(&quot;/WEB-INF/jsp/hello.jsp&quot;).forward(request，response);    &#125;&#125;\n新建JSP WEB-INF/jsp/hello.jsp\n123456789&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;    &lt;head&gt;        &lt;title&gt;Title&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        Hello World! - Servlet    &lt;/body&gt;&lt;/html&gt;\n配置版\n使用Spring MVC，第一步先引入依赖：\n123456&lt;!--Spring MVC--&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework&lt;/groupId&gt;    &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;    &lt;version&gt;5.2.6.RELEASE&lt;/version&gt;&lt;/dependency&gt;\n\n看别人的笔记，SpringMVC 引入了两个包，除了spring-webmvc，还有一个groupId 和 version 都相同的叫做spring-web的包。\n有点疑惑，遂删了试一下，运行正常。搜了一下，发现spring-webmvc 依赖于 且 将隐式引入 spring-web包。\n具体原文参考：https://stackoverflow.com/questions/13533700/maven-dependency-spring-web-vs-spring-webmvc\n\n然后在web.xml配置DispatcherServlet：\n1234567891011121314151617181920&lt;!--1.注册DispatcherServlet，负责处理所有请求--&gt;&lt;servlet&gt;    &lt;servlet-name&gt;spring_mvc&lt;/servlet-name&gt;    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;    &lt;!--初始化时加载配置参数--&gt;    &lt;init-param&gt;        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;        &lt;param-value&gt;classpath:springmvc-servlet.xml&lt;/param-value&gt;    &lt;/init-param&gt;    &lt;!--容器启动时立即加载此Servlet--&gt;    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt;&lt;!-- 匹配所有的请求 ([/]:不包括.jsp  [/*]:包括.jsp  但两者都会匹配静态资源*.js，*.html等)--&gt;&lt;servlet-mapping&gt;    &lt;servlet-name&gt;spring_mvc&lt;/servlet-name&gt;    &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;\n接着在IoC上下文容器配置其他组件，resources/springmvc-servlet.xml：\n1234567891011121314151617181920&lt;!--2.HandlerMapping 映射器--&gt;&lt;!--根据配置或者注解找到最终要执行的Handler--&gt;&lt;bean class=&quot;org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping&quot;/&gt;&lt;!--3.ControllerHandlerAdapter 适配器--&gt;&lt;!--根据Handler规则执行不同类型的Handler，返回ModelAndView--&gt;&lt;bean class=&quot;org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter&quot;/&gt;&lt;!--4.视图解析器--&gt;&lt;!--将ModelAndView 逻辑视图 解析成 真正的视图 国际化处理 返回View--&gt;&lt;!--最后 DispatcherServlet 会渲染视图，将Model 数据转为response 响应--&gt;&lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot; id=&quot;InternalResourceViewResolver&quot;&gt;    &lt;!--前缀--&gt;    &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot;/&gt;    &lt;!--后缀--&gt;    &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt;&lt;/bean&gt;&lt;!--Handler--&gt;&lt;bean id=&quot;/hello&quot; class=&quot;com.chenyuxi.controller.HelloController&quot;/&gt;\ncom.chenyuxi.controller.HelloController：\n1234567891011121314public class HelloController implements Controller &#123;    public ModelAndView handleRequest(HttpServletRequest httpServletRequest， HttpServletResponse httpServletResponse) throws Exception &#123;        // ModelAndView 模型和视图        ModelAndView mv = new ModelAndView();        // 封装对象，放在ModelAndView中。Model        mv.addObject(&quot;msg&quot;， &quot;Hello World! - Spring MVC&quot;);        // 封装要跳转的视图，放在ModelAndView中        mv.setViewName(&quot;hello&quot;);        return mv;    &#125;&#125;\n这里 HelloController 返回一个 ModelAndView，根据上面的Spring MVC 工作时序图可得知最后会被 视图解析器ViewResolver 渲染。\n其ViewName为 hello，url 会根据前后缀被拼接为WEB-INF/jsp/hello.jsp。\n并带上我们添加的对象msg，转发到拼接后的url。\n在jsp里，可以直接用EL 表达式访问此对象：\n123456789&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;    &lt;head&gt;        &lt;title&gt;Title&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        $&#123;msg&#125;    &lt;/body&gt;&lt;/html&gt;\n浏览器输入URL 看到效果：\n\n注解版\n上述方法较为麻烦，下面来看一下注解版：\n首先Web.xml配置DispatcherServler不变。\nIoC上下文容器配置：\n1234567891011121314151617&lt;!--自动扫描bean--&gt;&lt;context:component-scan base-package=&quot;com.chenyuxi.controller&quot;/&gt;&lt;!-- 让Spring MVC不处理静态资源 --&gt;&lt;mvc:default-servlet-handler/&gt;&lt;!--       支持mvc注解驱动       在spring中一般采用@RequestMapping 注解来完成映射关系 要想使@RequestMapping 注解生效       必须向上下文中注册DefaultAnnotationHandlerMapping 和AnnotationMethodHandlerAdapter 实例       这两个实例分别在类级别和方法级别处理，而annotation-driven 帮助我们自动完成上述两个实例的注入--&gt;&lt;mvc:annotation-driven/&gt;&lt;!--视图解析器--&gt;&lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot; id=&quot;InternalResourceViewResolver&quot;&gt;    &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot;/&gt;    &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt;&lt;/bean&gt;\ncom.chenyuxi.controller.HelloController：\n12345678910111213141516@Controller@RequestMapping(&quot;/HelloController&quot;)public class HelloController &#123;    // 真实访问地址: &#123;项目名&#125;/HelloController/hello    @RequestMapping(&quot;/hello&quot;)    public String sayHello(Model model) &#123;        // 向模型中添加属性msg与值，可以在JSP页面中取出并渲染        model.addAttribute(&quot;msg&quot;， &quot;hello，SpringMVC&quot;);        // WEB-INF/jsp/hello.jsp        return &quot;hello&quot;;    &#125;&#125;\n浏览器输入URL 即可看到效果：\n\nController\n\n控制器负责提供访问应用程序的行为，通常通过接口定义或注解定义两种方法实现。\n控制器负责解析用户的请求并将其转换为一个模型。\n在Spring MVC中一个控制器类可以包含多个方法。\n在Spring MVC中，对于Controller的配置方式有很多种。\n\n实现接口方式\n12345678910public class XXXXXController implements Controller &#123;    public ModelAndView handleRequest(HttpServletRequest Request， HttpServletResponse Response) throws Exception &#123;                ModelAndView mv = new ModelAndView();        //....                return mv;    &#125;&#125;\n实现接口Controller定义控制器是较老的办法。\n缺点：\n\n一个控制器中只有一个方法，如果要多个方法则需要定义多个Controller。\n定义的方式比较麻烦。\n\n注解方式\n使用注解@Controller声明被标注的类是一个控制器。\nSpring 可以使用扫描机制来找到应用程序中所有基于注解的控制器类。\n为了保证Spring能找到控制器，需要在配置文件中声明组件扫描。\n12&lt;!-- 自动扫描指定的包，下面所有注解类交给IOC容器管理 --&gt;&lt;context:component-scan base-package=&quot;com.kuang.controller&quot;/&gt;\nRequestMapping\n注解位置\n@RequestMapping注解可用于控制器类的类或方法上。\n如果标注于类上，表示类中的所有响应请求的方法都是以其name属性作为父路径。\ne.g.：\n1234567891011@Controller@RequestMapping(&quot;/HelloController&quot;)public class HelloController &#123;        @RequestMapping(&quot;/hello&quot;)    public String sayHello(Model model) &#123;        // ...        return &quot;hello&quot;;    &#125;&#125;\n则其URL 为 &#123;项目名&#125;/HelloController/hello。\n注解属性\n@RequestMapping 注解常用的属性有四个：value/path、method、params、headers。\n\n\nvalue/path：请求路径\n\n\n支持通配符：\n\n\n@GetMapping(&quot;/a/*&quot;) //请求地址可以是/a/xxxxxx\n@GetMapping(&quot;/a/*/c&quot;) //请求地址可以是/a/xxxxxx/c\n12345678910111213141516171819- method：**限制请求方式**  - RequestMethod.GET  - RequestMethod.POST  - RequestMethod.DELETE  - RequestMethod.HEAD  - RequestMethod.OPTIONS  - RequestMethod.PATCH  - RequestMethod.PUT  - RequestMethod.TRACE- params：**限制请求参数**  - ```java    // 指定了age = 2，则 age 必须 为2    @RequestMapping(value = &quot;/hello&quot;，method = RequestMethod.GET，params = &#123;&quot;name&quot;，&quot;age=2&quot;&#125;)        // 请求方式：&#123;host&#125;/&#123;project_name&#125;/hello?name=chenyuxi&amp;age=18\n\n\n\n\n\n\nheaders：限制请求头数据\n\n\n@RequestMapping(value = &quot;/hello&quot;，method = RequestMethod.GET，headers =&quot;Connection=keep-alive&quot;)\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758### 组合注解&gt; Spring 4.3 引入了方法级注解的变体，也被叫做 @RequestMapping 的组合注解。&gt;&gt; 它们所扮演的角色就是针对 @RequestMapping 的封装，而且成了定义端点的标准方法。 例如，`@GetMapping` 是一个组合注解，它所扮演的是 @RequestMapping(method =RequestMethod.GET) 的一个快捷方式。诸如此类的组合注解有：- @GetMapping- @PostMapping- @PutMapping- @DeleteMapping- @PatchMapping尽管每个变体都可以使用带有方法属性的 @RequestMapping 注解来互换实现，但组合变体仍然是一种最佳的实践。这主要是因为组合注解**减少了在应用程序上要配置的元数据**，并且**组合注解可以更好的表达被注解方法的语义**。 ### @PathVariable在Spring MVC中可以使用  `@PathVariable` 注解，让方法**参数的值**对应绑定到一个URL**模板变量**上。使用路径变量，路径会变得更加简洁，获得参数会更加方便，并且框架会自动进行类型转换。通过路径变量的类型可以约束访问参数，如果类型不一样，则访问不到对应的请求方法。如下面例子访问是的路径是/commit/1/a，则结果是路径与方法不匹配（通常返回 400 状态码），而不会是参数转换失败。e.g.：```java@Controllerpublic class RestFulController &#123;   // 映射访问路径   @RequestMapping(&quot;/commit/&#123;p1&#125;/&#123;p2&#125;&quot;)   public String index(@PathVariable int p1， @PathVariable int p2， Model model)&#123;              int result = p1 + p2;              // Spring MVC会自动实例化一个Model对象用于向视图中传值       model.addAttribute(&quot;msg&quot;， &quot;结果：&quot; + result);              // 返回视图位置       return &quot;test&quot;;         &#125;   &#125;\n\n\n\n\n\n\n此时访问url host/commit/1/2，正常情况下显示：\n1结果：3\n此注解有两个属性：\n\nvalue/name：要绑定到的路径变量的名称。\nrequire：指示路径变量是否为必需。\n\nRESTful\n概念\nREST这个词，是Roy Thomas Fielding在他2000年的博士论文中提出的。翻译过来就是&quot;表现层状态转化&quot;。\nRESTful 是一个资源定位及资源操作的风格。不是标准、规范也不是协议，只是一种风格。\n基于这个风格设计的API 可以更简洁，更有层次，更易于实现缓存等机制。\n最佳实践\n以下摘自 文末参考 [RESTful API 最佳实践 - 阮一峰] 部分。\n一、URL 设计\n1.1 动词 + 宾语\nRESTful 的核心思想就是，客户端发出的数据操作指令都是&quot;动词 + 宾语&quot;的结构。\n比如，GET /articles这个命令，GET是动词，/articles是宾语。\n动词通常就是五种 HTTP 方法，对应 CRUD 操作。\n\n\nGET：读取（Read）\nPOST：新建（Create）\nPUT：更新（Update）\nPATCH：更新（Update），通常是部分更新\nDELETE：删除（Delete）\n\n\n根据 HTTP 规范，动词一律大写。\n1.2 动词的覆盖\n有些客户端只能使用GET和POST这两种方法。服务器必须接受POST模拟其他三个方法（PUT、PATCH、DELETE）。\n这时，客户端发出的 HTTP 请求，要加上X-HTTP-Method-Override属性，告诉服务器应该使用哪一个动词，覆盖POST方法。\n12POST /api/Person/4 HTTP/1.1 X-HTTP-Method-Override: PUT\n上面代码中，X-HTTP-Method-Override指定本次请求的方法是PUT，而不是POST。\n1.3 宾语必须是名词\n宾语就是 API 的 URL，是 HTTP 动词作用的对象。它应该是名词，不能是动词。比如，/articles这个 URL 就是正确的，而下面的 URL 不是名词，所以都是错误的。\n\n\n/getAllCars\n/createNewCar\n/deleteAllRedCars\n\n\n1.4 复数 URL\n既然 URL 是名词，那么应该使用复数，还是单数？\n这没有统一的规定，但是常见的操作是读取一个集合，比如GET /articles（读取所有文章），这里明显应该是复数。\n为了统一起见，建议都使用复数 URL，比如GET /articles/2要好于GET /article/2。\n1.5 避免多级 URL\n常见的情况是，资源需要多级分类，因此很容易写出多级的 URL，比如获取某个作者的某一类文章。\n1GET /authors/12/categories/2\n这种 URL 不利于扩展，语义也不明确，往往要想一会，才能明白含义。\n更好的做法是，除了第一级，其他级别都用查询字符串表达。\n1GET /authors/12?categories=2\n下面是另一个例子，查询已发布的文章。你可能会设计成下面的 URL。\n1GET /articles/published\n查询字符串的写法明显更好。\n1GET /articles?published=true\n二、状态码\n服务器向用户返回的状态码和提示信息，常见的有以下一些（方括号中是该状态码对应的HTTP动词）。\n\n\n200 OK - [GET]：服务器成功返回用户请求的数据，该操作是幂等的（Idempotent）。\n201 CREATED - [POST/PUT/PATCH]：用户新建或修改数据成功。\n202 Accepted - [*]：表示一个请求已经进入后台排队（异步任务）\n204 NO CONTENT - [DELETE]：用户删除数据成功。\n400 INVALID REQUEST - [POST/PUT/PATCH]：用户发出的请求有错误，服务器没有进行新建或修改数据的操作，该操作是幂等的。\n401 Unauthorized - [*]：表示用户没有权限（令牌、用户名、密码错误）。\n403 Forbidden - [*] 表示用户得到授权（与401错误相对），但是访问是被禁止的。\n404 NOT FOUND - [*]：用户发出的请求针对的是不存在的记录，服务器没有进行操作，该操作是幂等的。\n406 Not Acceptable - [GET]：用户请求的格式不可得（比如用户请求JSON格式，但是只有XML格式）。\n410 Gone -[GET]：用户请求的资源被永久删除，且不会再得到的。\n422 Unprocesable entity - [POST/PUT/PATCH] 当创建一个对象时，发生一个验证错误。\n500 INTERNAL SERVER ERROR - [*]：服务器发生错误，用户将无法判断发出的请求是否成功。\n\n\n三、服务器回应\n3.1 不要返回纯文本\nAPI 返回的数据格式，不应该是纯文本，而应该是一个 JSON 对象，因为这样才能返回标准的结构化数据。所以，服务器回应的 HTTP 头的Content-Type属性要设为application/json。\n客户端请求时，也要明确告诉服务器，可以接受 JSON 格式，即请求的 HTTP 头的ACCEPT属性也要设成application/json。下面是一个例子。\n12GET /orders/2 HTTP/1.1 Accept: application/json\n3.2 发生错误时，不要返回 200 状态码\n略。很严谨，但目前阶段小项目没必要。可以再原文参考。\n3.3 提供链接\n略。很好但很麻烦，不知道有没有自动生成HATEOAS 的技术，大型项目总不可能手动写吧… 挖个坑先以后填。\nAPI文档、测试工具\n这俩玩应没来得及研究，先mark一下，有空填坑。\n前后端分离模式下，前端与后端人员如何合作？.md\nSwagger\nhttps://swagger.io/\n一分钟 SSM框架集成 swagger\nEolinker\nhttps://www.eolinker.com/\n参考\n理解RESTful架构 - 阮一峰\nRESTful API 设计指南 - 阮一峰\nRESTful API 最佳实践 - 阮一峰\n幂等 - MDN Web Docs\n如何理解 RESTful 的幂等性 - 掘金\nController 视图跳转\n\n以下参考：https://juejin.cn/post/6844903838332239879\n\nModelAndView\n以前前后端不分的情况下，ModelAndView 应该是最最常见的返回值类型了，现在前后端分离后，后端都是以返回 JSON 数据为主了。\n后端返回 ModelAndView 这个比较容易理解，开发者可以在 ModelAndView 对象中指定视图名称，然后也可以绑定数据，像下面这样：\n12345678910111213141516171819202122232425@RequestMapping(&quot;/book&quot;)public ModelAndView getAllBook() &#123;    ModelAndView mv = new ModelAndView();        List&lt;Book&gt; books = new ArrayList&lt;&gt;();        Book b1 = new Book();    b1.setId(1);    b1.setName(&quot;三国演义&quot;);    b1.setAuthor(&quot;罗贯中&quot;);    books.add(b1);        Book b2 = new Book();    b2.setId(2);    b2.setName(&quot;红楼梦&quot;);    b2.setAuthor(&quot;曹雪芹&quot;);    books.add(b2);        //指定数据模型    mv.addObject(&quot;bs&quot;， books);    mv.setViewName(&quot;book&quot;);//指定视图名        return mv;&#125;\n结果将通过视图解析器**转发(默认)**到指定页面：{视图解析器前缀} + viewName + {视图解析器后缀}\n也可以通过指定ViewName前缀redirect:来重定向到指定页面。\nServlet\n使用Servlet 方式，不需要视图解析器：\n12345678910111213141516171819@Controller @RequestMapping(&quot;/Servlet&quot;)public class ServletJumpController &#123;    @GetMapping(&quot;/t1&quot;)    public void test1(HttpServletRequest request， HttpServletResponse response) throws IOException &#123;        response.setContentType(&quot;text/html;charset=UTF-8&quot;);        response.getWriter().println(&quot;通过HttpServletResponse进行输出&quot;);    &#125;    @GetMapping(&quot;/t2&quot;)    public void test2(HttpServletRequest request， HttpServletResponse response) throws IOException &#123;        response.sendRedirect(&quot;/3/forward.jsp&quot;);    &#125;    @GetMapping(&quot;/t3&quot;)    public void test3(HttpServletRequest request， HttpServletResponse response) throws IOException， ServletException &#123;        request.getRequestDispatcher(&quot;/redirect.jsp&quot;).forward(request，response);    &#125;&#125;\n返回 void，然后可以直接使用request / response 进行输出、转发、重定向。\nSpringMVC\n如果Mapping方法的返回类型是String ，SpringMVC 会自动对以下几种自动进行处理。\n有无视图解析器会直接影响到结果：\n123456789101112131415161718192021222324@Controller @RequestMapping(&quot;SpringMVC&quot;)public class SpringMvcJumpController &#123;    @GetMapping(&quot;/t1&quot;)    public String test1()&#123;        // 有视图解析器会自动拼接前后缀        // return &quot;forward&quot;;                // 无视图解析器直接转发        return &quot;/forward.jsp&quot;;    &#125;    @GetMapping(&quot;/t2&quot;)    public String test2()&#123;        return &quot;forward:/forward.jsp&quot;;    &#125;    @GetMapping(&quot;/t3&quot;)    public String test3()&#123;        // 重定向        return &quot;redirect:/redirect.jsp&quot;;    &#125;&#125;\nController 参数绑定\n\n以下参考：\n\n四种常见的POST提交数据方式\nspringmvc接收参数的几种方式\n\n\n以下请求方式都需要为application/x-www-form-urlencoded，即?name=tom&amp;age=18这种键值对形式。\n属性名\n通过属性名接收参数：\n1234@RequestMapping(&quot;/t1&quot;)public String Test1(String username， String password) &#123;    return username + &quot;，&quot; + password;&#125;\nSpringMVC 会根据方法参数名寻找对应请求参数，请求若没有对应参数，则方法参数为Null。\nBean 对象\n通过Bean 对象接收参数：\n12345678910111213141516@Datapublic class Book &#123;    private String name;&#125;@Datapublic class User &#123;    private String username;    private String password;    private Book book;&#125;@RequestMapping(&quot;/t2&quot;)public String Test2(User user) &#123;    return user.getUsername() + &quot;，&quot; + user.getPassword() + &quot;，&quot; + user.getBook().getName();&#125;\n参数为一个Bean 对象时，spring mvc会尝试将值注入到对应同名属性。\n通过Bean 来接收请求数据，必须要有set方法，请求参数名不对应或没有set方法，则为Null。\n使用此方式接收请求数据，还支持级联赋值，比如上述例子在User对象的属性里还有一个Book对象，\n可以使用 ?username=admin&amp;password=666&amp;book.name=Tom形式进行级联传参。\nHttpServletRequest\n当然也可以使用原来HttpServlet 的方式来接收请求参数：\n123456@RequestMapping(&quot;/t3&quot;)public String Test3(HttpServletRequest request) &#123;    String username = request.getParameter(&quot;username&quot;);    String password = request.getParameter(&quot;password&quot;);    return username + &quot;，&quot; + password;&#125;\n不常用，需要自己处理类型转换和异常。\n@PathVariable\n使用@PathVariable 注解来接收参数，会将请求路径中对应的数据注入到方法参数中：\n123456789101112@RequestMapping(value = &#123;    &quot;/t4/&#123;username&#125;/&#123;password&#125;&quot;，    &quot;/t4/&#123;username&#125;/&#123;password&#125;/&#123;role&#125;&quot;&#125;)public String Test4(    @PathVariable String username，    @PathVariable(value = &quot;password&quot;) String cipher，    @PathVariable(required = false) String role) &#123;        return username + &quot;，&quot; + cipher + &quot;，&quot; + role;&#125;\n如果方法参数名和路径变量名不对应，可以使用name/value指定。\n如果一个参数不是必须的，可以先在@RequestMapping 中指定多个value，然后将对应参数注解的required 设为 false。\n@RequestParam\n12345678910@RequestMapping(&quot;/t5&quot;)public String Test5(    String username，    @RequestParam(value = &quot;password&quot;) String cipher，    @RequestParam(defaultValue = &quot;18&quot;) String age，    @RequestParam(required = false) String role) &#123;    // 通过@RequestParam 获取请求参数    return username + &quot;，&quot; + cipher + &quot;，&quot; + age + &quot;，&quot; + role;&#125;\n如果不需要用到@RequestParam 中的属性可以直接使用属性名形式接收数据。\n如果方法参数名和请求数据名不对应，可以使用name/value指定。\n参数默认不能为空，如果有需求，可以将required 设为 false。\n与@PathVariable 的属性有一点不同的是，defaultValue可以为其设置默认值。\n返回 String 乱码\nSpring MVC的StringHttpMessageConverter，默认编码是ISO-8859-1。\n但其提供了对应的有参构造方法：\n\n所以，解决办法：\n\n先在Web.xml 配置过滤器（这一步已经可以解决部分乱码了，例如Jsp 传参乱码）：\n\n12345678910111213&lt;!--Spring Web 自带的字符编码过滤器，统一编码为UTF-8--&gt;&lt;filter&gt;    &lt;filter-name&gt;encoding&lt;/filter-name&gt;    &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;    &lt;init-param&gt;        &lt;param-name&gt;encoding&lt;/param-name&gt;        &lt;param-value&gt;utf-8&lt;/param-value&gt;    &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt;    &lt;filter-name&gt;encoding&lt;/filter-name&gt;    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt;\n\n然后在Spring 容器上下文配置String 消息转换器，覆盖默认编码类型：\n\n1234567&lt;mvc:annotation-driven&gt;    &lt;mvc:message-converters&gt;        &lt;bean class=&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;&gt;            &lt;constructor-arg name=&quot;defaultCharset&quot; value=&quot;UTF-8&quot;/&gt;        &lt;/bean&gt;    &lt;/mvc:message-converters&gt;&lt;/mvc:annotation-driven&gt;\n返回 JSON\n这个小章节看上去简单但知识量其实不算少。\n因为喜欢追根究底~~(钻牛角尖)，故花了较多时间研究(踩了很多坑)~~。\n首先这是下面用到的JavaBean：\n123456789101112131415@Data@AllArgsConstructor@NoArgsConstructorpublic class User &#123;    private String username;    private String password;    private Book book;&#125;@Data@AllArgsConstructor@NoArgsConstructorpublic class Book &#123;    private String name;&#125;\n1.使用Jackson 返回 Json 字符串\nJackson 是 maven 仓库存储库中下载量最多的Java Json解析库。\nJackson 是 SpringMVC 的默认Json解析器。\n自己使用Jackson来将JavaBean转为Json字符串， 需要先引入依赖：\n1234567&lt;jackson-databind.version&gt;2.9.8&lt;/jackson-databind.version&gt;&lt;dependency&gt;    &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;    &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;    &lt;version&gt;$&#123;jackson-databind.version&#125;&lt;/version&gt;&lt;/dependency&gt;\n完整的Jackson 依赖有三个jar 包，但只要引入一个jackson-databind就够了，剩下的jackson-core和jackson-annotations是传递依赖，会被maven 隐式引入。\n123456789@GetMapping(&quot;/t1&quot;)public String test1() throws JsonProcessingException &#123;    User user = new User(&quot;汤姆&quot;， &quot;123456&quot;， new Book(&quot;西游记&quot;));        ObjectMapper objectMapper = new ObjectMapper();        return objectMapper.writeValueAsString(user);&#125;\nObjectMapper 是Jackson 的对象映射器，调用其writeValueAsString()方法可将Java 对象直接转换为 Json 字符串，效果：\n\n就是这里，坑了老子好久，看图，注意标注位置：\n\n因为控制器返回的是String 类型，经过了StringHttpMessageConverter，所以其Content-Type为text/html;charset=UTF-8，不是一个标准的Json类型Http响应，而是一个Json字符串。\n但标准前后端分离模式应该返回application/json;charset=UTF-8。\n对于单个RequestMapping ，可以设置produces属性将其修改为一个Json 类型响应：\n1@GetMapping(value = &quot;/t1&quot;，produces = &quot;application/json;charset=UTF-8&quot;)\n对于全局的转换方法暂没有找到有效的，找了一个多小时，脑壳都昏了，想着又不是搞科研的，不折磨自己了。\n2.使用HttpServlet 直接输出\n这种方式，较为灵活~~(较为原始)~~，但方法较多时，同样也不简洁：\n1234567891011@GetMapping(&quot;/t5&quot;)public void test5(HttpServletResponse response) throws IOException &#123;    User user = new User(&quot;汤姆&quot;， &quot;123456&quot;， new Book(&quot;西游记&quot;));    ObjectMapper objectMapper = new ObjectMapper();    String s = objectMapper.writeValueAsString(user);    response.setContentType(&quot;application/json;charset=UTF-8&quot;);    response.getWriter().print(s);&#125;\n可以直接将以下 ServletAPI 作为Handler 方法参数，SpringMVC 会自动将值注入：\n\nHttpServletRequest\nHttpServletRespons\nHttpSession\nInputStream\nOutputStream\nReader\nOuter\n\n3.直接返回Object\n如果使用 @RestController 或 @ResponseBody 注解，直接返回JavaBean、Map、List，Spring MVC 默认会使用内置Jackson 将其转为Json 响应。\nJavaBean\n1234567@GetMapping(&quot;/t2&quot;)public User test2() &#123;    User user = new User(&quot;Demo&quot;， &quot;123456&quot;， new Book(&quot;红楼梦&quot;));    return user;&#125;\nMap、List\n12345678910111213141516171819202122@GetMapping(&quot;/t4&quot;)public Map test4() &#123;    List list = new ArrayList();    list.add(&quot;1&quot;);    list.add(2);    list.add(3.0f);    int[] ints = &#123;1， 2， 3&#125;;    // 无序：HashMap、Hashtable    // 有序：TreeMap(按key 升序)、LinkedHashMap(插入顺序)    Map&lt;String， Object&gt; map = new LinkedHashMap&lt;&gt;();    map.put(&quot;username&quot;， &quot;汤姆&quot;);    map.put(&quot;password&quot;， &quot;123456&quot;);    map.put(&quot;book&quot;， new Book(&quot;水浒传&quot;));    map.put(&quot;null&quot;， null);    map.put(&quot;collections&quot;， Collections.emptyList());    map.put(&quot;Array&quot;， ints);    map.put(&quot;List&quot;，list);    return map;&#125;\nExpected Output：\n123456789&#123;  &quot;username&quot; : &quot;汤姆&quot;，  &quot;password&quot; : &quot;123456&quot;，  &quot;book&quot; : &#123;&quot;name&quot; : &quot;水浒传&quot;&#125;，  &quot;null&quot; : null，  &quot;collections&quot; : [ ]，  &quot;Array&quot; : [ 1， 2， 3 ]，  &quot;List&quot; : [ &quot;1&quot;， 2， 3.0 ]&#125;\nNull值 和 时间格式 的处理\n未处理的响应\n12345678910@GetMapping(&quot;/t3&quot;)public User test3() &#123;    // 没有值的字段默认会返回Null    User user = new User();    user.setUsername(&quot;威廉&quot;);    user.setBook(new Book(&quot;三国演义&quot;));    return user;&#125;\n上述代码的User 对象，缺省 password 属性。\n如果不经过处理，返回给前端的将是：\n1234567&#123;  &quot;username&quot; : &quot;威廉&quot;，  &quot;password&quot; : null，  &quot;book&quot; : &#123;    &quot;name&quot; : &quot;三国演义&quot;  &#125;&#125;\n1234567@GetMapping(&quot;/t6&quot;)public Map test6()&#123;    Date date = new Date();    Map&lt;String， Object&gt; map = new LinkedHashMap&lt;&gt;();    map.put(&quot;date&quot;，date);    return map;&#125;\n上述代码返回一个Date 对象，但默认为时间戳：\n123&#123;  &quot;date&quot; : 1614239835279&#125;\n处理方案\nSpring 默认使用jackson 将原响应转换为Json 响应，其中是通过消息转换器实现的。\n即 org.springframework.http.converter.json.MappingJackson2HttpMessageConverter。\n可以通过覆写MappingJackson2HttpMessageConverter中的ObjectMapper，来改变其中某些默认配置：\n12345678910111213141516171819202122232425&lt;bean id=&quot;objectMapper&quot; class=&quot;com.fasterxml.jackson.databind.ObjectMapper&quot;&gt;    &lt;!--全局忽略null 字段，适用嵌套--&gt;    &lt;property name=&quot;serializationInclusion&quot; value=&quot;NON_NULL&quot;/&gt;    &lt;!--全局转换时间格式--&gt;    &lt;property name=&quot;dateFormat&quot;&gt;        &lt;bean class=&quot;java.text.SimpleDateFormat&quot;&gt;            &lt;constructor-arg index=&quot;0&quot; value=&quot;yyyy-MM-dd HH:mm:ss&quot;/&gt;        &lt;/bean&gt;    &lt;/property&gt;&lt;/bean&gt;&lt;mvc:annotation-driven&gt;    &lt;mvc:message-converters&gt;        &lt;!--配置String 的消息转换器，将默认编码ISO_8859_1 修改为UTF-8--&gt;        &lt;bean class=&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;&gt;            &lt;constructor-arg name=&quot;defaultCharset&quot; value=&quot;UTF-8&quot;/&gt;        &lt;/bean&gt;        &lt;!--配置Jackson 消息转换器--&gt;        &lt;bean class=&quot;org.springframework.http.converter.json.MappingJackson2HttpMessageConverter&quot;&gt;            &lt;!--覆写Jackson 消息转换器中的objectMapper--&gt;            &lt;property name=&quot;objectMapper&quot; ref=&quot;objectMapper&quot;/&gt;            &lt;!--格式化打印--&gt;            &lt;property name=&quot;prettyPrint&quot; value=&quot;true&quot;/&gt;        &lt;/bean&gt;    &lt;/mvc:message-converters&gt;&lt;/mvc:annotation-driven&gt;\n（以上：格式化json 输出、处理默认中文乱码、处理时间格式、全局忽略null 字段）\nSSM整合\n自己搭了个简单的SSM脚手架方便以后复用，整合过程代码就不贴了，大部分都很简单。\n踩了一个坑搞了挺长时间记录一下：\napplication-context可以分为多个文件，service、dao、mvc等，最后import导入到主 application-context.xml。\n\nweb.xml 一定要配置为主application-context，不能为 mvc 那个文件，不然问题多多：\n1234&lt;init-param&gt;    &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;    &lt;param-value&gt;classpath:spring/application-context.xml&lt;/param-value&gt;&lt;/init-param&gt;\n文件上传下载\n​\t文件上传是项目开发中最常见的功能之一 SspringMVC 可以很好的支持文件上传，但是SpringMVC上下文中默认没有装配MultipartResolver，因此默认情况下其不能处理文件上传工作。如果想使用Spring的文件上传功能，则需要在上下文中配置MultipartResolver。\n​\t前端表单要求：为了能上传文件，必须将表单的method设置为POST，并将enctype设置为multipart/form-data。只有在这样的情况下，浏览器才会把用户选择的文件以二进制数据发送给服务器。\n1.导入依赖：\n123456789101112&lt;!--文件上传--&gt;&lt;dependency&gt;   &lt;groupId&gt;commons-fileupload&lt;/groupId&gt;   &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt;   &lt;version&gt;1.3.3&lt;/version&gt;&lt;/dependency&gt;&lt;!--servlet-api导入高版本的--&gt;&lt;dependency&gt;   &lt;groupId&gt;javax.servlet&lt;/groupId&gt;   &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;   &lt;version&gt;4.0.1&lt;/version&gt;&lt;/dependency&gt;\n2.配置 multipartResolver\n12345678&lt;!--文件上传配置，id必须为：multipartResolver，否则上传文件会报400--&gt;&lt;bean id=&quot;multipartResolver&quot;  class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt;    &lt;!-- 请求的编码格式，必须和jSP的pageEncoding属性一致，以便正确读取表单的内容，默认为ISO-8859-1 --&gt;    &lt;property name=&quot;defaultEncoding&quot; value=&quot;utf-8&quot;/&gt;    &lt;!-- 上传文件大小上限，单位为字节（10485760=10M） --&gt;    &lt;property name=&quot;maxUploadSize&quot; value=&quot;10485760&quot;/&gt;    &lt;property name=&quot;maxInMemorySize&quot; value=&quot;40960&quot;/&gt;&lt;/bean&gt;\nCommonsMultipartFile 的 常用方法：\n\nString getOriginalFilename()：获取上传文件的原名\nInputStream getInputStream()：获取文件流\nvoid transferTo(File dest)：将上传文件保存到一个目录文件中\n\n3.前端表单\n123456&lt;body&gt;    &lt;form action=&quot;/upload&quot; enctype=&quot;multipart/form-data&quot; method=&quot;post&quot;&gt;        &lt;input type=&quot;file&quot; name=&quot;file&quot;/&gt;        &lt;input type=&quot;submit&quot; value=&quot;upload&quot;&gt;    &lt;/form&gt;&lt;/body&gt;\n4.Controller\n1234567891011121314151617181920212223242526272829303132333435363738394041@RequestMapping(&quot;/upload&quot;)public String fileUpload(@RequestParam(&quot;file&quot;) CommonsMultipartFile file， HttpServletRequest request) throws IOException &#123;    // @RequestParam(&quot;file&quot;) 将name=file控件得到的文件封装成CommonsMultipartFile 对象    // 批量上传CommonsMultipartFile则为数组即可    // 获取文件名 : file.getOriginalFilename();    String uploadFileName = file.getOriginalFilename();    // 如果文件名为空，直接回到首页！    if (&quot;&quot;.equals(uploadFileName)) &#123;        return &quot;redirect:/index.jsp&quot;;    &#125;    System.out.println(&quot;上传文件名 : &quot; + uploadFileName);    // 上传路径保存设置    String path = request.getServletContext().getRealPath(&quot;/upload&quot;);    // 如果路径不存在，创建一个    File realPath = new File(path);    if (!realPath.exists()) &#123;        realPath.mkdir();    &#125;    System.out.println(&quot;上传文件保存地址：&quot; + realPath);    // 文件输入流、输出流    InputStream is = file.getInputStream();    OutputStream os = new FileOutputStream(new File(realPath， uploadFileName));    // 读取写出    int len = 0;    byte[] buffer = new byte[1024];    while ((len = is.read(buffer)) != -1) &#123;        os.write(buffer， 0， len);        os.flush();    &#125;    os.close();    is.close();    return &quot;redirect:/index.jsp&quot;;&#125;\n没问题的话，就OK了：\n\n也可以 使用 file.Transto 来保存上传的文件：\n1234567891011121314151617@RequestMapping(&quot;/upload2&quot;)public String fileUpload2(@RequestParam(&quot;file&quot;) CommonsMultipartFile file， HttpServletRequest request) throws IOException &#123;    //上传路径保存设置    String path = request.getServletContext().getRealPath(&quot;/upload&quot;);    File realPath = new File(path);    if (!realPath.exists()) &#123;        realPath.mkdir();    &#125;    //上传文件地址    System.out.println(&quot;上传文件保存地址：&quot; + realPath);    //通过CommonsMultipartFile的方法直接写文件（注意这个时候）    file.transferTo(new File(realPath + &quot;/&quot; + file.getOriginalFilename()));    return &quot;redirect:/index.jsp&quot;;&#125;\n文件下载：\n12345678910111213141516171819202122232425262728293031@RequestMapping(value = &quot;/download&quot;)    public String downloads(HttpServletResponse response， HttpServletRequest request) throws Exception &#123;        // 要下载的图片地址        String path = request.getServletContext().getRealPath(&quot;/upload&quot;);        String fileName = &quot;图片1.png&quot;;        // 1、设置response 响应头        // 设置页面不缓存，清空buffer        response.reset();        response.setCharacterEncoding(&quot;UTF-8&quot;); //字符编码        response.setContentType(&quot;multipart/form-data&quot;); //二进制传输数据        // 设置响应头        response.setHeader(&quot;Content-Disposition&quot;， &quot;attachment;fileName=&quot; + URLEncoder.encode(fileName， &quot;UTF-8&quot;));        File file = new File(path， fileName);        // 2、 读取文件--输入流        InputStream input = new FileInputStream(file);        // 3、 写出文件--输出流        OutputStream out = response.getOutputStream();        byte[] buff = new byte[1024];        int index = 0;        // 4、执行 写出操作        while ((index = input.read(buff)) != -1) &#123;            out.write(buff， 0， index);            out.flush();        &#125;        out.close();        input.close();        return null;    &#125;\n异常处理器\n处理思路\n在Spring MVC 中异常处理的思路：\n\n系统中异常分为两类：\n\n预期异常\n运行时异常 RuntimeException\n\n前者通过捕获异常从而获取异常信息，后者主要通过规范代码开发、测试通过手段减少运行时异常的发生。\n系统的dao、service、controller出现都可以通过throws Exception向上抛出，最后由springmvc 前端控制器交由异常处理器进行异常处理。\n处理方式\n在Spring MVC中处理异常有 4种方式：\n（1）使用Spring MVC提供的简单异常处理器 SimpleMappingExceptionResolver；\n（2）实现Spring的异常处理接口 HandlerExceptionResolver 自定义自己的异常处理器；\n（3）使用 @ExceptionHandler 注解实现异常处理；\n（4）使用 @ControllerAdvice + @ExceptionHandler\n这里使用 @ControllerAdvice + @ExceptionHandler 处理，使API 发生异常时返回包含错误信息和原因的Json ：\n@ControllerAdvice，是Spring3.2提供的新注解，它是一个Controller 增强版，可对controller中被 @RequestMapping注解的方法加一些逻辑处理。最常用的就是异常处理。\n@ExceptionHandler，ExceptionHandler\n先自定义一个异常类，继承 Exception：\n1234567891011121314151617181920212223package com.chenyuxi.exception;/** * 系统 自定义异常类，针对预期的异常，需要在程序中抛出此类的异常 */public class CustomException extends Exception &#123;    //异常信息    public String message;    public CustomException(String message) &#123;        super(message);        this.message = message;    &#125;    public String getMessage() &#123;        return message;    &#125;    public void setMessage(String message) &#123;        this.message = message;    &#125;&#125;\n再自定义一个异常处理器，实现HandlerExceptionResolver 接口：\n1234567891011121314151617181920212223package com.chenyuxi.controller;import com.chenyuxi.exception.CustomException;import org.springframework.web.bind.annotation.ExceptionHandler;import org.springframework.web.bind.annotation.ResponseBody;import org.springframework.web.bind.annotation.RestControllerAdvice;import java.util.LinkedHashMap;import java.util.Map;@RestControllerAdvicepublic class CustomHandlerExceptionResolver &#123;    @ExceptionHandler(CustomException.class)    @ResponseBody    public Map&lt;String， Object&gt; resolveException(CustomException e) &#123;        Map&lt;String， Object&gt; map = new LinkedHashMap&lt;&gt;();        map.put(&quot;code&quot;， &quot;-1&quot;);        map.put(&quot;msg&quot;， &quot;操作失败，原因：&quot; + e.message + &quot;，异常：&quot; + e.toString());        return map;    &#125;&#125;\n最后在springmvc.xml 配置一下全局异常处理器：\n12&lt;!-- 全局异常处理器--&gt;&lt;bean class=&quot;com.chenyuxi.controller.CustomHandlerExceptionResolver&quot;&gt;&lt;/bean&gt;\n测试\n在controller、service、dao中任意一处手动抛出异常。\n如果是程序中手动抛出的异常，可以在错误页面中显示自定义的异常信息，如果不是手动抛出异常说明是一个运行时异常，在错误页面只显示“未知错误”。\n1234567891011121314151617/** * 测试异常处理 */@RestControllerpublic class ExceptionController &#123;    @GetMapping(&quot;/ex1&quot;)    public Map&lt;String，Object&gt; testException1() throws CustomException &#123;        Map&lt;String， Object&gt; map = new LinkedHashMap&lt;&gt;();        map.put(&quot;username&quot;， &quot;汤姆&quot;);        map.put(&quot;password&quot;， &quot;123456&quot;);        throw new CustomException(&quot;发生了一个小错误!&quot;);    &#125;&#125;\n\n如果与业务功能相关的异常，建议在service中抛出。\n与业务功能没有关系的异常，建议在controller中抛出。\n\n参考链接1\n参考链接2\n拦截器\n\nSpring MVC中的拦截器(Interceptor)类似于Servlet中的过滤器(Filter)，主要用于拦截用户请求并做相应的处理，例如通过拦截器可以进行权限验证，记录请求信息的日志，判断用户是否登录等\n\n**过滤器与拦截器的区别：**拦截器是AOP思想的具体应用。\n过滤器\n\nservlet规范中的一部分，任何java web工程都可以使用\n在url-pattern中配置了/*之后，可以对所有要访问的资源进行拦截\n\n拦截器\n\n拦截器是SpringMVC框架自己的，只有使用了SpringMVC框架的工程才能使用\n拦截器只会拦截访问的控制器方法， 如果访问的是jsp/html/css/image/js等静态资源是不会进行拦截的\n\n要使用Spring MVC中的拦截器，就需要对拦截器类进行定义和配置，通常拦截器类可以通过两种方式来定义，如下所示：\n\n实现HandlerInterceptor接口，或继承HandlerInterceptor接口的实现类，如HandlerInterceptorAdapter。\n实现WebRequestInterceptor接口，或继承WebRequestInterceptor接口的实现类。\n\n\n实现HandlerInterceptor接口例子：\n1、编写一个自定义拦截器：\n1234567891011121314151617181920212223public class CustomInterceptor implements HandlerInterceptor &#123;    // 在请求处理的方法之前执行    // 如果返回true执行下一个拦截器    // 如果返回false就不执行下一个拦截器    @Override    public boolean preHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o) throws Exception &#123;        System.out.println(&quot;------------处理前------------&quot;);        return true;    &#125;    // 在请求处理方法执行之后执行    @Override    public void postHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, ModelAndView modelAndView) throws Exception &#123;        System.out.println(&quot;------------处理后------------&quot;);    &#125;    // 在dispatcherServlet处理后执行,做清理工作.    @Override    public void afterCompletion(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e) throws Exception &#123;        System.out.println(&quot;------------清理------------&quot;);    &#125;&#125;\n2、在spring mvc的配置文件中配置拦截器\n1234567891011&lt;!--拦截器--&gt;&lt;mvc:interceptors&gt;    &lt;mvc:interceptor&gt;        &lt;!--/** 包括路径及其子路径--&gt;        &lt;!--/admin/* 拦截的是/admin/add 这种子路径, /admin/add/user 不会被拦截--&gt;        &lt;!--/admin/** 拦截的是/admin/ 及其所有后代路径--&gt;        &lt;mvc:mapping path=&quot;/**&quot;/&gt;        &lt;!--bean配置的就是拦截器--&gt;        &lt;bean class=&quot;com.chenyuxi.interceptor.CustomInterceptor&quot;/&gt;    &lt;/mvc:interceptor&gt;&lt;/mvc:interceptors&gt;\n3、用于测试的Controller\n1234567891011121314151617/** * 测试拦截器的Controller */@RestControllerpublic class InterceptorTestController &#123;    @GetMapping(&quot;/interceptor&quot;)    public Map&lt;String,Object&gt; interceptorTest() &#123;        Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();        map.put(&quot;msg&quot;,&quot;hello&quot;);        System.out.println(&quot;interceptorTest Ran..&quot;);        return map;    &#125;&#125;\n访问/interceptor后，控制台输出：\n1234------------处理前------------interceptorTest Ran..------------处理后------------------------清理------------\n参考链接1\n参考链接2\nJSR-303数据校验\n参考链接1\n参考链接2\n参考链接3\n","plink":"https://www.tzcat8.cn/SpringMVC/"},{"title":"关于我","date":"2021-10-17T17:45:11.000Z","date_formatted":{"ll":"2021年10月17日","L":"2021/10/17","MM-DD":"10-17"},"updated":"2021-12-20T12:07:38.421Z","content":"Todo\n","plink":"https://www.tzcat8.cn/about/"},{"title":"友情链接","date":"2021-10-17T17:49:58.000Z","date_formatted":{"ll":"2021年10月17日","L":"2021/10/17","MM-DD":"10-17"},"updated":"2021-12-20T12:07:38.421Z","content":"Todo\n","plink":"https://www.tzcat8.cn/friends/"}]