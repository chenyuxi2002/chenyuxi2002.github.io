[{"title":"Spring Boot","date":"2022-01-01T01:01:01.000Z","date_formatted":{"ll":"2022年1月1日","L":"2022/01/01","MM-DD":"01-01"},"updated":"2021-10-17T06:44:36.622Z","content":"资料\n文档\n\nSpring Boot 参考文档\n\nGetting Started（入门）\nDeveloping with Spring Boot（使用 Spring Boot 开发）\nSpring Boot 特性\n\n源码\nspring-projects/spring-boot at v2.5.4\nSpring Boot Plus\n发现一个好玩的，没来得及研究：spring-boot-plus\n主要特性\n\n集成spring boot 常用开发组件集、公共配置、AOP日志等\nMaven多模块架构\n集成mybatis plus快速dao操作\n快速生成后台代码: entity/param/vo/controller/service/mapper/xml\n集成Swagger/Knife4j，可自动生成api文档\n集成jwt、shiro权限控制\n集成Redis缓存\n集成HikariCP连接池，JDBC性能和慢查询检测\n集成spring boot admin，实时检测项目运行情况\n使用assembly maven插件进行不同环境打包部署,包含启动、重启命令，配置文件提取到外部config目录\n\n启动流程\n\n概述\n什么是 Spring Boot？\nSpring Boot 是 Spring 开源组织下的子项目，是 Spring 组件一站式解决方案，主要是简化了使用\nSpring 的难度，简省了繁重的配置，提供了各种启动器，开发者能快速上手。\nSpring Boot 有哪些优点？\nSpring Boot 主要有如下优点：\n\n容易上手，提升开发效率，为 Spring 开发提供一个更快、更广泛的入门体验。\n开箱即用，远离繁琐的配置。\n提供了一系列大型项目通用的非业务性功能，例如：内嵌服务器、安全管理、运行数据监控、运行\n状况检查和外部化配置等。\n没有代码生成，也不需要XML配置。\n避免大量的 Maven 导入和各种版本冲突。\n\n时代背景\n微服务\nJames Lewis and Martin Fowler (2014) 提出微服务完整概念：Microservices Guide。译文：微服务｜YYGCui’s blog\n\n\n微服务是一种架构风格\n\n\n一个应用拆分为一组小型服务\n\n\n每个服务运行在自己的进程内，也就是可独立部署和升级\n\n\n服务之间使用轻量级HTTP交互\n\n\n服务围绕业务功能拆分\n\n\n可以由全自动部署机制独立部署\n\n\n去中心化，服务自治。服务可以使用不同的语言、不同的存储技术。\n\n\n分布式\n\n分布式带来了新的困难：\n\n\n远程调用\n\n\n服务发现\n\n\n负载均衡\n\n\n服务容错\n\n\n配置管理\n\n\n服务监控\n\n\n链路追踪\n\n\n日志管理\n\n\n任务调度\n\n\n…\n\n\n\n发现宝藏😍：凤凰架构：构筑可靠的大型分布式系统 | 凤凰架构\n\n云原生\n上云的困难：\n\n\n服务自愈\n\n\n弹性伸缩\n\n\n服务隔离\n\n\n自动化部署\n\n\n灰度发布\n\n\n流量治理\n\n\n…\n\n\n\n入门\nHello World\n1234567891011121314&lt;parent&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;    &lt;version&gt;2.5.4&lt;/version&gt;    &lt;relativePath/&gt; &lt;!-- lookup parent from repository(从存储库中查找父项) --&gt;&lt;/parent&gt;&lt;dependencies&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;\n12345678910// com/example/springboot/SpringbootReviewApplication.java@SpringBootApplicationpublic class SpringbootReviewApplication &#123;    public static void main(String[] args) &#123;        SpringApplication.run(SpringbootReviewApplication.class, args);    &#125;&#125;\n1234567891011// com/example/springboot/controller/HelloController.java@RestController@RequestMapping(&quot;/&quot;)public class HelloController &#123;    @RequestMapping(&quot;/hello&quot;)    public String hello()&#123;        return &quot; Hello Spring Boot ! &quot;;    &#125;&#125;\n启动引导类：\n\n\n起步依赖\nSpringBoot 项目父工程的父工程spring-boot-dependencies-2.5.4.pom 定义了常用依赖及版本，并避免了冲突：\n\n配置\n配置文件分类\nSpringBoot是基于约定的，所以很多配置都有默认值，但如果想使用自己的配置替换默认配置的话，就可以使用application.properties 或者application.yml (或 application.yaml) 进行配置。\n优先级：properties &gt; yml &gt; yaml\nyaml 基本语法\n参考：YAML 入门教程 | 菜鸟教程\n读取配置文件\n\n\n@Value\n单个属性注入，数量少比较方便\n\n\nEnvironment\n注入获取此对象，通过此对象的方法来获取值\n\n\n@ConfigurationProperties\n可以将配置文件直接映射成一个实体类\n\n\n12345678910111213141516171819# application.ymlserver:  port: 8083cyx:  name: chenyuxi  age: 19  address:    - beijing    - shanghai    - changsha    - guangzhou    - hangzhou# 纯量msg1: &#x27;hello \\n world&#x27; #不会识别转义字符msg2: &quot;hello \\n world&quot; #会识别转义字符\n1234567891011121314// Cyx.java@Data@AllArgsConstructor@NoArgsConstructor@Component@ConfigurationProperties(prefix = &quot;cyx&quot;)public class Cyx &#123;    private String name;    private int age;    private String[] address;&#125;\n12345678910111213141516171819202122232425262728293031323334353637383940@RestController@RequestMapping(&quot;/&quot;)public class HelloController &#123;    @Value(&quot;$&#123;cyx.name&#125;&quot;)    private String name;    @Value(&quot;$&#123;cyx.age&#125;&quot;)    private String age;    @Value(&quot;$&#123;cyx.address[0]&#125;&quot;)    private String address;    @Value(&quot;$&#123;msg1&#125;&quot;)    private String msg1;    @Value(&quot;$&#123;msg2&#125;&quot;)    private String msg2;    private final Cyx cyx;    private final Environment environment;    public HelloController(Environment environment, Cyx cyx) &#123;        this.environment = environment;        this.cyx = cyx;    &#125;    @RequestMapping(&quot;/hello&quot;)    public String hello() &#123;        System.out.println(&quot;name = &quot; + name);        System.out.println(&quot;age = &quot; + age);        System.out.println(&quot;address = &quot; + address);        System.out.println(&quot;msg1 = &quot; + msg1);        System.out.println(&quot;msg2 = &quot; + msg2);        System.out.println(&quot;---------------------------------&quot;);        System.out.println(environment.getProperty(&quot;cyx.name&quot;));        System.out.println(environment.getProperty(&quot;cyx.address[0]&quot;));        System.out.println(&quot;---------------------------------&quot;);        System.out.println(&quot;cyx = &quot; + cyx);        return &quot;hello&quot;;    &#125;&#125;\noutput：\n1234567891011name = chenyuxiage = 19address = beijingmsg1 = hello \\n worldmsg2 = hello  world---------------------------------chenyuxibeijing---------------------------------cyx = Cyx(name=chenyuxi, age=19, address=[beijing, shanghai, changsha, guangzhou, hangzhou])\n在上面例子中，使用了@ConfigurationProperties注解，可以使配置自动映射成实体类。\n有几个注意点：\n\n\n引入配置处理器依赖：\n1234&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt;&lt;/dependency&gt;\n\n\n实体类需要加上注解：@Component\n\n\n@ConfigurationProperties(prefix = &quot;cyx&quot;) 可以指定前缀，如果配置有前缀必须指定。\n\n\nprofile （动态切换配置）\n我们在开发Spring Boot应用时，通常同一套程序会被安装到不同环境，比如：开发、测试、生产等。其中数据库地址、服务器端口等等配置都不同，如果每次打包时，都要修改配置文件，那么非常麻烦。profile 功能就是来进行动态配置切换的。\nprofile 配置方式\n多profile文件方式\n\nyml 多文档方式\n\nprofile 激活方式\n配置文件\n如上。\n虚拟机参数\n-Dspring.profiles.active=test\n\n命令行参数\n--spring.profiles.active=pro\n\n内部配置加载顺序\nSpringboot程序启动时，会从以下位置加载配置文件：\n\nfile:/config/:当前项目下的/config目录下\nfile:/:当前项目的根目录\nclasspath:/config/：classpath的/config 目录\nclasspath:/：classpath的根目录\n\n加载顺序为上文的排列顺序，高优先级配置的属性会生效\n外部配置加载顺序\nSpring Boot 允许你从外部加载配置，这样的话，就可以在不同的环境中使用相同的代码。支持的外部配置源包括：Java属性文件、YAML文件、环境变量、命令行参数。\n参考：\n\nSpring Boot 加载外部配置文件 - 废物大师兄 - 博客园\n2.外部配置 - Spring Boot 特性\n\n容器功能注解\n组件添加\n@Configuration、@Bean、@ComponentScan\n@Configuration 标注在类上，相当于把该类作为 spring 的 xml 配置文件中的 &lt;beans&gt;，作用为：配置 spring 容器 (应用上下文)。配置类本身也是组件。\n@Configuration(proxyBeanMethods = &#123;boolean&#125;)：\n\n\n Full(proxyBeanMethods = true) 【保证每个@Bean 方法被调用多少次返回的组件都是单实例的】\n\n\n\n Lite(proxyBeanMethods = false)【每个@Bean 方法被调用多少次返回的组件都是新创建的】\n\n\n\n 组件依赖必须使用Full模式【默认】。\n\n\n\n配置类里面使用 @Bean 标注在方法上给容器注册组件，以方法名作为组件的id，默认是单实例的。\n12345678@Configuration(proxyBeanMethods = true)public class MyConfig &#123;    @Bean    public User user01()&#123;        User zhangsan = new User(&quot;zhangsan&quot;, 18);        return zhangsan;    &#125;&#125;\n@ComponentScan 相当于 &lt;context:component-scan&gt;。\n可以指定 basePackageClasses() 或 basePackages()（或其别名 value()）来定义要扫描的特定包。如果没有定义特定的包，将从声明该注解的类的包开始扫描。\n@Component、@Controller、@Service、@Repository\n\n\n注解\n含义\n\n\n\n\n@Component\n最普通的组件，可以被注入到 spring 容器进行管理\n\n\n@Repository\n作用于持久层\n\n\n@Service\n作用于业务逻辑层\n\n\n@Controller\n作用于表现层（spring-mvc 的注解）\n\n\n@Import\n使用@Import导入的类会被Spring加载到IOC容器中，默认组件的名字就是全类名。\n@Import提供4种用法：\n① 导入Bean\n② 导入配置类\n③ 导入 ImportSelector 实现类。一般用于加载配置文件中的类\n④ 导入 ImportBeanDefinitionRegistrar 实现类。\n@Condition\n\n思考：SpringBoot是如何知道要创建哪个Bean的？\n为什么导入了spring-boot-starter-data-redis包，SpringBoot就自动创建了Redis 相关的Bean（如RedisTemplate）呢？\n\n@Condition 是在 Spring4.0 增加的条件判断功能，通过这个注解可以动态地决定是否要创建某个Bean，在满足指定条件的时候才将某个 bean 加载到应用上下文中。\n更多参考：Spring Boot @Condition 注解，组合条件你知道吗 - 掘金\n原生配置文件引入\n@ImportResource\n@ImportResource(&quot;classpath:beans.xml&quot;)\n通过 locations 属性加载对应的 xml 配置文件，同时需要配合 @Configuration 注解一起使用，定义为配置类。\n自动装配\n参考：\n\n淘宝一面：“说一下 Spring Boot 自动装配原理呗？” - JavaGuide - 博客园\n\n什么是SpringBoot 自动装配？\n使用Spring 时需要配置很多的XML 。即使 Spring 后面引入了基于注解的配置，在开启某些 Spring 特性或者引入第三方依赖的时候，还是需要用 XML 或 Java 进行显式配置。\n例如使用Spring MVC 写个简单的RESTful 接口，都需要配置一大堆东西，例如：\n123456789101112131415161718192021222324252627282930313233&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; .....&gt;    &lt;context:component-scan base-package=&quot;com.chenyuxi.controller&quot;/&gt;    &lt;mvc:default-servlet-handler/&gt;    &lt;bean id=&quot;objectMapper&quot; class=&quot;com.fasterxml.jackson.databind.ObjectMapper&quot;&gt;        &lt;!--全局忽略null 字段,适用嵌套--&gt;        &lt;property name=&quot;serializationInclusion&quot; value=&quot;NON_NULL&quot;/&gt;        &lt;!--全局转换时间格式--&gt;        &lt;property name=&quot;dateFormat&quot;&gt;            &lt;bean class=&quot;java.text.SimpleDateFormat&quot;&gt;                &lt;constructor-arg index=&quot;0&quot; value=&quot;yyyy-MM-dd HH:mm:ss&quot;/&gt;            &lt;/bean&gt;        &lt;/property&gt;    &lt;/bean&gt;    &lt;mvc:annotation-driven&gt;        &lt;mvc:message-converters&gt;            &lt;!--配置String 的消息转换器，将默认编码ISO_8859_1 修改为UTF-8--&gt;            &lt;bean class=&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;&gt;                &lt;constructor-arg name=&quot;defaultCharset&quot; value=&quot;UTF-8&quot;/&gt;            &lt;/bean&gt;            &lt;!--配置Jackson 消息转换器--&gt;            &lt;bean class=&quot;org.springframework.http.converter.json.MappingJackson2HttpMessageConverter&quot;&gt;                &lt;!--覆写Jackson 消息转换器中的objectMapper--&gt;                &lt;property name=&quot;objectMapper&quot; ref=&quot;objectMapper&quot;/&gt;                &lt;!--格式化打印--&gt;                &lt;property name=&quot;prettyPrint&quot; value=&quot;true&quot;/&gt;            &lt;/bean&gt;        &lt;/mvc:message-converters&gt;    &lt;/mvc:annotation-driven&gt;&lt;/beans&gt;\n加上之后配置事务、Mybatis、…等等，就更多了。\n但是在Spring Boot 项目中，只需要添加相关 Starter，无需配置，通过 main 方法运行即可。\n那为什么不用配置了呢？这些配置去哪了呢？\n其实是Spring Boot 帮我们自动按常用习惯（约定）配置好了。并且，我们还能通过 Spring Boot 的全局配置文件 application.properties 或 application.yml 等对项目进行自定义设置，比如更换端口号，配置 JPA 属性等等。\n实际上 Spring Framework 早就实现了这个自动装配。\nSpring Boot 只是在其基础上，通过 SPI 的方式，做了进一步优化：\n\nSPI ，全称为 Service Provider Interface(服务提供者接口)，是一种服务发现机制。它通过在classpath路径下的META-INF/services 文件夹查找文件，自动加载文件中所定义的类。\n\nSpringBoot 定义了一套接口规范，这套规范规定：SpringBoot 在启动时会扫描外部引用 jar 包中的 META-INF/spring.factories 文件，将文件中配置的类型信息加载到 Spring 容器（此处涉及到 JVM 类加载机制与 Spring 的容器知识），并执行类中定义的各种操作。对于外部 jar 来说，只需要按照 SpringBoot 定义的标准，就能将自己的功能装置进 SpringBoot。\n这就是Spring Boot 自动配置的基本实现原理。\n原理分析\n@SpringBootApplication挨个分析：\n\n@SpringBootConfiguration\n@EnableAutoConfiguration\n@ComponentScan\n\n@SpringBootConfiguration\n就是@Configuration。\n@ComponentScan\n扫描被 @Component (@Service,@Controller) 注解的 bean，注解默认会扫描启动类所在的包下所有的类 ，可以自定义不扫描某些 bean。\n123456// 排除 TypeExcludeFilter 和 AutoConfigurationExcludeFilter@ComponentScan(excludeFilters = &#123;     @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),    @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;)\n@EnableAutoConfiguration\n@EnableAutoConfiguration 也是一个合成注解。\n1234567891011121314151617181920212223242526// ...@AutoConfigurationPackage@Import(AutoConfigurationImportSelector.class)public @interface EnableAutoConfiguration &#123;   /**    * Environment property that can be used to override when auto-configuration is    * enabled.    */   String ENABLED_OVERRIDE_PROPERTY = &quot;spring.boot.enableautoconfiguration&quot;;   /**    * Exclude specific auto-configuration classes such that they will never be applied.    * @return the classes to exclude    */   Class&lt;?&gt;[] exclude() default &#123;&#125;;   /**    * Exclude specific auto-configuration class names such that they will never be    * applied.    * @return the class names to exclude    * @since 1.3.0    */   String[] excludeName() default &#123;&#125;;&#125;\n此注解由@AutoConfigurationPackage和@Import(AutoConfigurationImportSelector.class)组成。\n\n@AutoConfigurationPackage 的作用是，将main 类路径包下的所有组件注册到容器中。\n@Import(AutoConfigurationImportSelector.class) 的作用是，导入AutoConfigurationImportSelector.class（自动配置类导入选择器），进而加载自动装配类 xxxxxxxxxxxAutoconfiguration 。\n\n自动装配核心功能，实际是通过 AutoConfigurationImportSelector 类实现的。\nAutoConfigurationImportSelector.class\n重点就是这个类，被导入到Spring Boot Application IOC 容器中了。\n它到底做了些什么事？使得Spring Boot 能够实现自动配置？\n首先分析下此类的继承体系，IDEA 快捷键（Windows）：Ctrl+Alt+Shift+U\n\n可以看出，AutoConfigurationImportSelector 类实现了 ImportSelector 接口，也就实现了这个接口中的 selectImports 方法。\nImportSelector\n该方法主要用于  获取所有符合条件的类的全限定类名，这些类需要被加载到 IoC 容器中。\n1String[] selectImports(AnnotationMetadata importingClassMetadata);\n12345678910111213141516private static final String[] NO_IMPORTS = &#123;&#125;;//...@Overridepublic String[] selectImports(AnnotationMetadata annotationMetadata) &#123;   // &lt;1&gt;.判断自动装配开关是否打开   if (!isEnabled(annotationMetadata)) &#123;       // 没打开返回空数组      return NO_IMPORTS;   &#125;   //&lt;2&gt;.开启了自动配置，则获取自动配置Entry   AutoConfigurationEntry autoConfigurationEntry = getAutoConfigurationEntry(annotationMetadata);   return StringUtils.toStringArray(autoConfigurationEntry.getConfigurations());&#125;\ngetAutoConfigurationEntry\n来到了getAutoConfigurationEntry(annotationMetadata) 方法：\n123456789101112131415161718192021222324252627/** * Return the &#123;@link AutoConfigurationEntry&#125; based on the &#123;@link AnnotationMetadata&#125; * of the importing &#123;@link Configuration @Configuration&#125; class. * @param annotationMetadata the annotation metadata of the configuration class * @return the auto-configurations that should be imported */protected AutoConfigurationEntry getAutoConfigurationEntry(AnnotationMetadata annotationMetadata) &#123;   if (!isEnabled(annotationMetadata)) &#123;      return EMPTY_ENTRY;   &#125;   // 根据annotationMetadata 获取attributes    AnnotationAttributes attributes = getAttributes(annotationMetadata);   // 根据annotationMetadata 和 attributes 获取候选配置类们   List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata, attributes);   // 给这些配置类去重   configurations = removeDuplicates(configurations);   // 检查并去除排除项   Set&lt;String&gt; exclusions = getExclusions(annotationMetadata, attributes);   checkExcludedClasses(configurations, exclusions);   configurations.removeAll(exclusions);   // 过滤一些什么玩意   configurations = getConfigurationClassFilter().filter(configurations);   // 获取所有的 AutoConfigurationImportListener 类型的监听器。并广播 Event 事件。不懂，没事。   fireAutoConfigurationImportEvents(configurations, exclusions);   // 封装成AutoConfigurationEntry 返回   return new (configurations, exclusions);&#125;\n重点是这句：List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata, attributes);\n获取到了所有候选配置类。后面的代码是进行一系列处理，然后封装返回。\n那就来到getCandidateConfigurations方法。\ngetCandidateConfigurations\n12345678910111213141516/** * Return the auto-configuration class names that should be considered. By default * this method will load candidates using &#123;@link SpringFactoriesLoader&#125; with * &#123;@link #getSpringFactoriesLoaderFactoryClass()&#125;. * @param metadata the source metadata * @param attributes the &#123;@link #getAttributes(AnnotationMetadata) annotation * attributes&#125; * @return a list of candidate configurations */protected List&lt;String&gt; getCandidateConfigurations(AnnotationMetadata metadata, AnnotationAttributes attributes) &#123;   List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(getSpringFactoriesLoaderFactoryClass(),         getBeanClassLoader());   Assert.notEmpty(configurations, &quot;No auto configuration classes found in META-INF/spring.factories. If you &quot;         + &quot;are using a custom packaging, make sure that file is correct.&quot;);   return configurations;&#125;\n注释写得很清楚了：\n@return a list of candidate configurations.\n返回候选配置列表。\nBy default this method will load candidates using &#123;@link SpringFactoriesLoader&#125; with &#123;@link #getSpringFactoriesLoaderFactoryClass()&#125;.\n默认情况下，此方法将使用 SpringFactoriesLoader 和 getSpringFactoriesLoaderFactoryClass（）加载候选项。\n也就是说Spring Boot 最后会通过Spring 工厂去加载候选配置项。\nloadSpringFactories\n再深入就到了loadSpringFactories方法。\n\nMETA-INF/spring.factories\n可以看到它是读取了所有依赖包的META-INF/spring.factories文件：\n\nMETA-INF/spring.factories 文件内容为starter 自定义的配置类，例如mybatis-starter 的：\n\n那么，这两个类就会自动被加载到Spring 容器中：\n\norg.mybatis.spring.boot.autoconfigure.MybatisLanguageDriverAutoConfiguration\norg.mybatis.spring.boot.autoconfigure.MybatisAutoConfiguration\n\n如此这般，所有依赖包的META-INF/spring.factories文件中的配置类，都会被读取进来。\n回到上层调用方法getCandidateConfigurations 打断点可以查看，一共读取了133个配置类：\n\n但才引入这么几个包：\n\norg.springframework.boot:spring-boot-starter-web:2.5.4\norg-projectlombok:lombok:1.18.20\norg-springframework.boot:spring-boot-configuration-processor:2.5.4\norg.springframework.boot:spring-boot-starter-test:2.5.4\norg-springframework.boot:spring-boot-starter-data-redis:2.5.4\nmysql:mysql-connector-java:8.0.26(runtime)\norg.mybatis.spring.boot:mybatis-spring-boot-starter:2.2.0\n\n咋就133个配置类了呢？这么多配置类，每次启动都要全部加载么？\n按需加载 @Condition\n继续单步，到返回语句。可以看到经过过滤后，只剩下了38个：\n\n这主要是@ConditinalOnXXXXXX （见：上文笔记@Condition）注解的功劳，它能实现按需加载配置项。\n比如Spring Boot 的Aop 自动配置类，只有在org.aspectj.weaver.Advice 类存在时才生效：\n\nSpring Boot 提供的常见条件注解：\n\n@ConditionalOnBean：当容器里有指定 Bean 的条件下\n@ConditionalOnMissingBean：当容器里没有指定 Bean 的情况下\n@ConditionalOnSingleCandidate：当指定 Bean 在容器中只有一个，或者虽然有多个但是指定首选 Bean\n@ConditionalOnClass：当类路径下有指定类的条件下\n@ConditionalOnMissingClass：当类路径下没有指定类的条件下\n@ConditionalOnProperty：指定的属性是否有指定的值\n@ConditionalOnResource：类路径是否有指定的值\n@ConditionalOnExpression：基于 SpEL 表达式作为判断条件\n@ConditionalOnJava：基于 Java 版本作为判断条件\n@ConditionalOnJndi：在 JNDI 存在的条件下差在指定的位置\n@ConditionalOnNotWebApplication：当前项目不是 Web 项目的条件下\n@ConditionalOnWebApplication：当前项目是 Web 项 目的条件下\n\n总结\nSpring Boot 通过 @EnableAutoConfiguration 开启自动装配，通过 SpringFactoriesLoader 最终加载 META-INF/spring.factories 中的自动配置类实现自动装配，自动配置其实就是通过 @Conditional 按需加载的配置类。\n查看自动装配的所有bean\n如何查看SpringBoot 启动时自动装配了哪些bean ？\n方法1\n通过ConfigurableApplicationContext 对象的getBeanDefinitionNames方法可以直接获取：\n12345678910111213141516171819@SpringBootApplicationpublic class SpringbootReviewApplication &#123;    public static void main(String[] args) &#123;        // 获取包含了所有初始化bean 的上下文容器        ConfigurableApplicationContext run = SpringApplication.run(SpringbootReviewApplication.class, args);        // 通过容器的API 方法获取容器内所有bean 的名字并打印        String[] beanDefinitionNames = run.getBeanDefinitionNames();        for (String beanDefinitionName : beanDefinitionNames) &#123;            System.out.println(&quot;beanDefinitionName = &quot; + beanDefinitionName);        &#125;        // 打印数量        System.out.println(&quot;run.getBeanDefinitionCount() = &quot; + run.getBeanDefinitionCount());    &#125;&#125;\n结果包含了我们自定义的Bean 和外部库的Bean ：\n\n简单引入几个依赖，Spring Boot 就给我初始化了两百多个Bean…\n方法2\n通过强大的IntelliJ 也可查看。IntelliJ 提供了Endpoint功能：\n\n并提供了多种筛选、视图：\n\n太强大了，一直在找这功能，原来藏在这里。\n方法3\n新发现的，更牛逼。\n\n自定义Starter\n参考：Spring Boot2 系列教程(六)自定义 Spring Boot 中的 starter\n所谓的 Starter ，其实就是一个普通的 Maven 项目，因此我们自定义 Starter ，需要首先创建一个普通的 Maven 项目，创建完成后，添加 Starter 的自动化配置类即可，如下：\n12345&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-autoconfigure&lt;/artifactId&gt;    &lt;version&gt;2.5.4&lt;/version&gt;&lt;/dependency&gt;\n配置完成后，我们首先创建一个 HelloProperties 类，用来接受 application.properties 中注入的值，以供初始Bean 时使用，如下：\n12345678910111213141516171819202122232425262728package com.chenyuxi;import org.springframework.boot.context.properties.ConfigurationProperties;@ConfigurationProperties(prefix = &quot;chenyuxi&quot;)public class HelloProperties &#123;    private static final String DEFAULT_NAME = &quot;默认Name子&quot;;    private static final String DEFAULT_MSG = &quot;默认Msg子&quot;;    private String name = DEFAULT_NAME;    private String msg = DEFAULT_MSG;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    public String getMsg() &#123;        return msg;    &#125;    public void setMsg(String msg) &#123;        this.msg = msg;    &#125;&#125;\n使用了@ConfigurationProperties注解，可以加上配置处理器：\n12345&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt;    &lt;version&gt;2.4.3&lt;/version&gt;&lt;/dependency&gt;\n要注入到HelloProperties 里面的值，也就是自动配置的默认属性：\n12345# application.ymlchenyuxi:  name: 皮卡丘  msg: abc\n配置完成 HelloProperties 后，接下来我们来定义一个 HelloService ，然后定义一个简单的 say 方法， HelloService 的定义如下：\n123456789101112131415161718192021222324252627package com.chenyuxi;public class HelloService &#123;    private String msg;    private String name;    public String sayHello() &#123;        return name + &quot; say &quot; + msg + &quot; !&quot;;    &#125;    public String getMsg() &#123;        return msg;    &#125;    public void setMsg(String msg) &#123;        this.msg = msg;    &#125;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;&#125;\n重点来了，写一个自动配置类，将HelloService 自动配置好并搞到容器里面去：\n123456789101112131415161718192021222324// 表明这是一个配置类@Configuration// 使 @ConfigurationProperties 注解的类生效@EnableConfigurationProperties(HelloProperties.class)// 当 HelloService.class 存在时，此配置类才生效@ConditionalOnClass(HelloService.class)public class HelloServiceAutoConfiguration &#123;    final HelloProperties helloProperties;    // 构造器注入    public HelloServiceAutoConfiguration(HelloProperties helloProperties) &#123;        this.helloProperties = helloProperties;    &#125;    @Bean    HelloService helloService() &#123;        // 赋予 HelloService 这个Bean 自动配置的值，并注册到容器中        HelloService helloService = new HelloService();        helloService.setName(helloProperties.getName());        helloService.setMsg(helloProperties.getMsg());        return helloService;    &#125;&#125;\n因为Spring Boot 的自动配置是通过扫描Starter 的META-INF/spring.factories 文件，所以最后还要搞一个这文件：\n123# resources/META-INF/spring.factoriesorg.springframework.boot.autoconfigure.EnableAutoConfiguration=com.chenyuxi.HelloServiceAutoConfiguration\n完成。\n本地安装，maven install。\n项目中引入：\n12345&lt;dependency&gt;    &lt;groupId&gt;org.example&lt;/groupId&gt;    &lt;artifactId&gt;TestCustomStarter&lt;/artifactId&gt;    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;&lt;/dependency&gt;\n已向Spring 容器自动注册了HelloService 并设置了默认值，接下来测试：\n123456789101112@SpringBootTestpublic class TestMyStarter &#123;    @Autowired    private HelloService helloService;    @Test    void testMyStarter() &#123;        System.out.println(&quot;helloService.sayHello() = &quot; + helloService.sayHello());    &#125;&#125;\n123output:helloService.sayHello() = 陈予希 say 哈哈哈子 !\n也可以在配置文件里，修改Starter 的默认值：\n123chenyuxi:  name: 卡布达  msg: 你好呀\n123output:helloService.sayHello() = 卡布达 say 你好呀 !\nWeb开发\n内置Web 服务器\nSpring Boot 内置了多种 Web 服务器，默认使用的是 Tomcat 。\n这个是Spring Boot 嵌入服务器的自动配置类。\n\n在自动配置类上有个@ConditionalOnWebApplication注解，表示在Web 应用程序中生效。\n\n同级包下有四个Web 服务器工厂定制器（Version 2.5.4）：\n\n在 自动配置类里的 对应几个Web服务器的 内部类 上，有个@ConditionalOnClass注解：当指定的类存在时生效。\n\n通过依赖传递，spring-boot-starter-web-&gt;spring-boot-starter-tomcat-&gt;tomcat-embed-core\nTomcat 类被引入，@ConditionalOnClass(&#123;Tomcat.class, UpgradeProtocol.class&#125;)生效。\n所以Spring Boot 启动时默认就以Tomcat 为Web 服务器。\n\n要修改Web 服务器，只需要排除tomcat-starter并引入对应web 服务器的starter即可，例如jetty：\n1234567891011121314&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;    &lt;exclusions&gt;        &lt;exclusion&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;        &lt;/exclusion&gt;    &lt;/exclusions&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-jetty&lt;/artifactId&gt;&lt;/dependency&gt;\n\nSpringMVC 自动配置\n官方文档说明：Spring Boot Features - 7.1.1.Spring MVC Auto-configuration\nSpring Boot 简化了 Spring Web MVC 的大部分配置，大多数场景都不需要自定义配置。\n\n\nContentNegotiatingViewResolver、BeanNameViewResolver： 视图解析器的支持\n\n\n支持提供静态资源（包括 webjars）\n\n\n自动注册 Converter，GenericConverter，Formatter\n\n\n对 HttpMessageConverters 的支持\n\n\n自动注册 MessageCodesResolver\n\n\nindex.html 支持\n\n\n自动使用一个 ConfigurableWebBindingInitializer： 可配置Web绑定初始化器\n\n\n…\n\n\n如果想保留 Spring Boot 的自动配置，并进行更多自定义（拦截器、格式化程序、视图控制器和其他功能），可以添加自己的 WebMvcConfigurer 类型的 @Configuration 类，但不要添加 @EnableWebMvc。\n\n\n声明一个类型为 WebMvcRegistrations 的 bean 可以改变默认底层组件。\n\n\n使用 @EnableWebMvc + @Configuration + DelegatingWebMvcConfiguration 可以全面接管 SpringMVC的配置。\n\n\n简单功能\n静态资源访问\n默认目录\n放在这几个目录下都可以。\n\n修改目录\n123spring:   resources:     static-locations: [classpath:/aaa/,classpath:/bbb/,...]\n映射顺序\n静态映射：/**\n请求进来，先去找 Controller 看能不能处理。不能处理的所有请求又都交给静态资源处理器。静态资源也找不到则响应 404 页面。\n添加访问前缀\n默认无前缀。\n123spring:  mvc:    static-path-pattern: /res/**\n欢迎页\n静态资源路径下  index.html 或 Controller  /index。\n自定义 Favicon\nfavicon.ico 放在静态资源目录下即可。\n模板引擎 Thymeleaf\nSpringBoot 默认不支持 JSP，需要引入第三方模板引擎技术实现服务端页面渲染。\n简介\nThymeleaf is a modern server-side Java template engine for both web and standalone environments, capable of processing HTML, XML, JavaScript, CSS and even plain text.\n文档\nDocumentation - Thymeleaf\nTutorial: Using Thymeleaf\n基本语法\n\n\n表达式名字\n语法\n用途\n\n\n\n\n变量取值\n${…}\n获取请求域、session 域、对象等值\n\n\n选择变量\n*{…}\n获取上下文对象值\n\n\n消息\n#{…}\n获取国际化等值\n\n\n链接\n@{…}\n生成链接\n\n\n片段表达式\n~{…}\njsp:include 作用，引入公共页面片段\n\n\n更多\n暂时懒得研究这么多了，用到再查。\n模板引擎Thymeleaf？来这一篇就够用了 - 掘金\nThymeleaf一篇就够了 - 掘金\n跨域 CORS\n同源策略\n同源指访问站点的：协议、域名、端口号必须一至，才叫同源。\n浏览器默认同源之间的站点是可以相互访问资源和操作 DOM 的，而不同源之间想要互相访问资源或者操作 DOM，那就需要加一些安全策略的限制，俗称同源策略。\n同源策略主要限制了三个方面：\n\nDOM 层面：不同源站点之间不能相互访问和操作 DOM。\n数据层面：不能获取不同源站点的 Cookie、LocalStorage、indexDB 等数据。\n网络层面：阻止读取 AJAX 请求不同源站点返回的内容，实际上请求依然发送到了服务器。\n\n好文：\n浏览器系列 - 只有浏览器才有 同源策略 吗？・Issue #28・HXWfromDJTU/blog\n为什么只有浏览器（或JS）是有所谓的同源策略？ - 知乎\n吃透浏览器安全（同源限制 / XSS/CSRF/ 中间人攻击） - 掘金\n同源策略 - 维基百科，自由的百科全书\nLyleMi/Learn-Web-Hacking: Study Notes For Web Hacking / Web安全学习笔记\nSpring Boot 实现 CORS\nCORS（跨域源资源共享）（CORS，Cross-origin resource sharing）\n使用 CORS 可以在前端代码不做任何修改的情况下，实现跨域。\n生动形象：\n\n使用@CrossOrigin注解，可以跨域指定接受某个地址的请求。\n123456789101112131415@RestControllerpublic class HelloController &#123;        @CrossOrigin(value = &quot;http://localhost:8081&quot;)    @GetMapping(&quot;/hello&quot;)    public String hello() &#123;        return &quot;hello&quot;;    &#125;        @CrossOrigin(value = &quot;http://localhost:8081&quot;)    @PostMapping(&quot;/hello&quot;)    public String hello2() &#123;        return &quot;post hello&quot;;    &#125;&#125;\n返回响应的时候会自动加上 Access-Control-Allow-Origin 响应头信息。告诉浏览器本服务器愿意将资源共享给此站点。这时浏览器就不会拦截XHR 获取响应数据了。\n\n@CrossOrigin 注解的参数可以限制请求的 origin、method、header\n默认：\n\n允许所有origins\n允许所有headers\n允许所有http方法\n\n\n在方法或类上使用@CrossOrigin 注解能细粒度控制。但如果需要全局配置的话，这种方式还是比较麻烦且低效。\n全局配置只需要在 SpringMVC 的配置类中重写 addCorsMappings 方法即可，如下\n123456789101112@Configurationpublic class WebMvcConfig implements WebMvcConfigurer &#123;    @Override    public void addCorsMappings(CorsRegistry registry) &#123;                registry.addMapping(&quot;/**&quot;)  // (&quot;/api/**&quot;)            .allowedOrigins(&quot;http://localhost:8081&quot;,&quot;http://localhost:8082&quot;)            .allowedMethods(&quot;*&quot;)\t// (&quot;PUT&quot;, &quot;DELETE&quot;)            .allowedHeaders(&quot;*&quot;);\t// (&quot;header1&quot;, &quot;header2&quot;, &quot;header3&quot;)            &#125;&#125;\nXML 相同配置：\n12345678&lt;mvc:cors&gt;    &lt;mvc:mapping path=&quot;/**&quot;        allowed-origins=&quot;http://localhost:8081, http://localhost:8082&quot;        allowed-methods=&quot;*&quot;        allowed-headers=&quot;*&quot; /&gt;&lt;/mvc:cors&gt;\n/** 表示本应用的所有请求Mapping  都会去处理跨域请求，allowedMethods 表示允许通过的请求方法，allowedHeaders 则表示允许的请求头。经过这样的配置之后，就不必在每个方法上单独配置跨域了。\nCSRF\n利用用户的登录状态发起跨站请求，比如邮箱里的乱七八糟的链接，打开链接的时候邮箱肯定是处于登录状态，然后就可以用这个登录状态，伪造带有正确 Cookie 的 http 请求，直接绕过后台的登录验证，然后冒充用户执行一些操作。\n发起 CSRF 攻击有三个必要条件：\n\n目标网站一定要有 CSRF 漏洞\n用户登录过目标网站，并且浏览器保存了登录状态\n需要用户主动打开第三方站点\n\n本质是利用 cookie 在同源请求中携带发送给服务器的特点，来实现冒充用户\nCSRF 攻击也有三种类型：GET 类型、 POST 类型、链接型\n\n自动发GET类型：比如 img 或 iframe 标签等，当用户打开这个网站时会自动发起带 Cookie 的资源请求\n\n12&lt;img src=&quot;http://恶意网址&quot; &gt;复制代码\n\n自动发POST类型：比如整一个隐藏的表单，在用户进入页面的时候自动提交表单\n\n12345&lt;form id=&quot;hack&quot; action=&quot;https://恶意网址&quot; method=&quot;post&quot;&gt;    ...&lt;/form&gt;&lt;script&gt;document.getElementById(&#x27;hack&#x27;).submit()&lt;/script&gt;复制代码\n\n诱导链接型：就是诱导用户主动点击链接，比如 a标签\n\n12&lt;a href=&quot;https://恶意网址&quot;&gt;点击领取大礼包&lt;/a&gt;&lt;a href=&quot;https://恶意网址&quot;&gt;点击下载美女视频&lt;/a&gt;\n更多参考：\n\n前端安全系列（二）：如何防止 CSRF 攻击？ - 美团技术团队\n吃透浏览器安全（同源限制 / XSS/CSRF/ 中间人攻击） - 掘金\n\n数据访问\n默认数据源\nSpring Boot 官方使用的数据源是：HikariCP。\n\n\n流行的数据源里HikariCP应该是速度最快，性能最高的。\n\n\n而Druid 功能全面、扩展性强、国内生态好，性能也还不错。\n\n\n还有个小众的数据源，BeeCP，光论速度的话好像比HikariCP还要快：Chris2018998/BeeCP: A High Performance JDBC Connection Pool(faster than HikariCP)\n\n\n各种数据源对比评测：\n\nHikariCP VS druid VS c3p0 VS dbcp VS jdbc 数据库连接池性能比对_Java &amp; Basketball-CSDN 博客\n对比各大数据库连接池技术 - Jdbc-Dbcp-C3p0-Druid-Hikaricp - 云 + 社区 - 腾讯云\n\ndruid 数据源starter 及文档：druid/druid-spring-boot-starter at master · alibaba/druid\n整合 Redis\nSpringBoot 1.5.x版本Redis客户端默认是Jedis实现的，SpringBoot 2.x版本中默认客户端是用Lettuce实现的。\n可参考：\n\nSpring Data Redis 最佳实践！ - 掘金\nRedis高级客户端Lettuce详解 - throwable - 博客园\n\n1234&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt;\n123456# application.ymlspring:  redis:    host: 192.168.40.138    port: 6379\n1234567891011121314151617181920212223package com.example.springboot;import org.junit.jupiter.api.Test;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.data.redis.core.StringRedisTemplate;@SpringBootTestpublic class SpringBootApplicationTest &#123;    @Autowired    private StringRedisTemplate stringRedisTemplate;    @Test    void testSet() &#123;        stringRedisTemplate.boundValueOps(&quot;name&quot;).set(&quot;chenyuxi&quot;);    &#125;    @Test    void testGet() &#123;        System.out.println(stringRedisTemplate.boundValueOps(&quot;name&quot;).get());    &#125;&#125;\n整合 Mybatis\n依赖：\n12345678910&lt;dependency&gt;    &lt;groupId&gt;mysql&lt;/groupId&gt;    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;    &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;    &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;    &lt;version&gt;2.2.0&lt;/version&gt;&lt;/dependency&gt;\n配置：\n12345678910111213141516# application.yml# 配置mysql地址连接属性等spring:  datasource:    driver-class-name: com.mysql.cj.jdbc.Driver    url: jdbc:mysql:///exam?useUnicode=true&amp;useSSL=false&amp;characterEncoding=utf8&amp;serverTimezone=Asia/Shanghai    username: root    password:# Mybatis的模型地址和Mapper.xml文件地址mybatis:  type-aliases-package: com.example.springboot.entity  mapper-locations: classpath*:mapper/*Mapper.xml#  指定mybatis 核心配置文件#  config-location:\n整合 Mybatis-Plus\n项目地址：baomidou/mybatis-plus: An powerful enhanced toolkit of MyBatis for simplify development\n依赖：\n12345&lt;dependency&gt;    &lt;groupId&gt;com.baomidou&lt;/groupId&gt;    &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt;    &lt;version&gt;3.4.3.3&lt;/version&gt;&lt;/dependency&gt;\n然后继承 BaseMapper接口，即可拥有CRUD 能力。\nService 层也封装好了，继承IService接口即可。如果要自定义通用 Service 方法，就创建自己的 IBaseService 继承 Mybatis-Plus 提供的基类。\nlearn more：简介 | MyBatis-Plus\n整合 Spring Data JPA\nJPA 是啥\nJava Persistence API：用于对象持久化的 API\nJava EE 5.0 平台标准的 ORM 规范，使得应用程序以统一的方式访问持久层\n\nJPA 和 Hibernate 的关系\nHibernate是 JPA的一种实现。\nJPA 包含的技术\n\n\nORM 映射元数据：JPA 支持 XML 和 JDK 5.0 注解两种元数据的形式，元数据描述对象和表之间的\n映射关系，框架据此将实体对象持久化到数据库表中。\n\n\nJPA 的 API：用来操作实体对象，执行CRUD操作，框架在后台完成所有的事情，开发者从繁琐的\nJDBC 和 SQL 代码中解脱出来。\n\n\n查询语言（JPQL）：这是持久化操作中很重要的一个方面，通过面向对象而非面向数据库的查询\n语言查询数据，避免程序和具体的 SQL 紧密耦合。\n\n\nJPQL\nSQL = Structur Query Language （结构化 查询语言）\nJPQL = Java Persistence Query Language （Java持久化 查询语言）\nSpring Data\nSpring Data 是 Spring 的一个子项目。用于简化数据库访问，支持NoSQL 和 关系数据存储。其主要目标是使数据库的访问变得方便快捷。\nMain modules\n\nSpring Data Commons - Core Spring concepts underpinning every Spring Data module.\nSpring Data JDBC - Spring Data repository support for JDBC.\nSpring Data JDBC Ext - Support for database specific extensions to standard JDBC including support for Oracle RAC fast connection failover, AQ JMS support and support for using advanced data types.\nSpring Data JPA - Spring Data repository support for JPA.\nSpring Data KeyValue - Map based repositories and SPIs to easily build a Spring Data module for key-value stores.\nSpring Data LDAP - Spring Data repository support for Spring LDAP.\nSpring Data MongoDB - Spring based, object-document support and repositories for MongoDB.\nSpring Data Redis - Easy configuration and access to Redis from Spring applications.\nSpring Data REST - Exports Spring Data repositories as hypermedia-driven RESTful resources.\nSpring Data for Apache Cassandra - Easy configuration and access to Apache Cassandra or large scale, highly available, data oriented Spring applications.\nSpring Data for Apache Geode - Easy configuration and access to Apache Geode for highly consistent, low latency, data oriented Spring applications.\nSpring Data for Pivotal GemFire - Easy configuration and access to Pivotal GemFire for your highly consistent, low latency/high through-put, data-oriented Spring applications.\n\nCommunity modules\n\nSpring Data Aerospike - Spring Data module for Aerospike.\nSpring Data ArangoDB - Spring Data module for ArangoDB.\nSpring Data Couchbase - Spring Data module for Couchbase.\nSpring Data Azure Cosmos DB - Spring Data module for Microsoft Azure Cosmos DB.\nSpring Data Cloud Datastore - Spring Data module for Google Datastore.\nSpring Data Cloud Spanner - Spring Data module for Google Spanner.\nSpring Data DynamoDB - Spring Data module for DynamoDB.\nSpring Data Elasticsearch - Spring Data module for Elasticsearch.\nSpring Data Hazelcast - Provides Spring Data repository support for Hazelcast.\nSpring Data Jest - Spring Data module for Elasticsearch based on the Jest REST client.\nSpring Data Neo4j - Spring-based, object-graph support and repositories for Neo4j.\nOracle NoSQL Database SDK for Spring Data - Spring Data module for Oracle NoSQL Database and Oracle NoSQL Cloud Service.\nSpring Data for Apache Solr - Easy configuration and access to Apache Solr for your search-oriented Spring applications.\nSpring Data Vault - Vault repositories built on top of Spring Data KeyValue.\nSpring Data YugabyteDB - Spring Data module for YugabyteDB distributed SQL database.\n\nSpring Data JPA\nSpring Data JPA 致力于减少数据访问层 (DAO) 的开发量. 开发者唯一要做的，就是声明持久层的接口，其他都交给 Spring Data JPA 来完成。\nSpring Data JPA 可以理解为 JPA 规范的再次封装抽象，底层还是使用了 Hibernate 的 JPA 技术实现。\n\n基本使用\n添加模块：\n1234&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;&lt;/dependency&gt;\n数据源是肯定要配置的：\n123456789101112spring:  datasource:    driver-class-name: com.mysql.cj.jdbc.Driver    url: jdbc:mysql:///exam?useUnicode=true&amp;useSSL=false&amp;characterEncoding=utf8&amp;serverTimeZone=Asia/ShangHai    username: root    password:  jpa:    # 在控制台打印sql    show-sql: true    # 每次启动项目时，数据库初始化策略    hibernate:      ddl-auto: update\n实体类，Spring Data JPA 会根据实体类自动生成Schema ：\n1234567891011121314@Entity(name = &quot;t_user&quot;)@Data@AllArgsConstructor@NoArgsConstructorpublic class User &#123;    @Id    @GeneratedValue(strategy = GenerationType.IDENTITY)    private Integer id;    @Column(name = &quot;name&quot;)    private String username;    private String address;&#125;\ndao 层，继承JpaRepository，两个参数，指定实体类和主键类型：\n123public interface UserDao extends JpaRepository&lt;User, Integer&gt; &#123;&#125;\n继承此类后接口就能获得一大把CRUD 方法。例如保存，更新，删除，分页查询等。\n也可以根据命名规范自定义方法，Spring Data JPA 将根据方法名称实现功能：\n1List&lt;User&gt; findByAddressEqualsAndIdLessThanEqual(String address, Integer id);\n命名实现不了的复杂sql，可以使用注解自定义 （Using @Query）：\n12@Query(value = &quot;select * from t_user where id=(select max(id) from t_user)&quot;, nativeQuery = true)User maxIdUser();\n单元测试\nSpring Boot 2.2.0 版本开始引入 JUnit 5 作为单元测试默认库。\nJunit 5 常用注解\n2.1. Annotations - JUnit 5 User Guide\n\n@Test : 表示方法是测试方法。但是与 JUnit4 的 @Test 不同，他的职责非常单一不能声明任何属性，拓展的测试将会由 Jupiter 提供额外测试。\n@ParameterizedTest : 表示方法是参数化测试\n@RepeatedTest : 表示方法可重复执行\n@DisplayName : 为测试类或者测试方法设置展示名称\n@BeforeEach : 表示在每个单元测试之前执行\n@AfterEach : 表示在每个单元测试之后执行\n@BeforeAll : 表示在所有单元测试之前执行\n@AfterAll : 表示在所有单元测试之后执行\n@Tag : 表示单元测试类别，类似于 JUnit4 中的 @Categories\n@Disabled : 表示测试类或测试方法不执行，类似于 JUnit4 中的 @Ignore\n@Timeout : 表示测试方法运行如果超过了指定时间将会返回错误\n@ExtendWith : 为测试类或测试方法提供扩展类引用\n\n断言\n用来对单个值进行简单的验证。如：\n简单断言：\n\n\n方法\n说明\n\n\n\n\nassertEquals\n判断两个对象或两个原始类型是否相等\n\n\nassertNotEquals\n判断两个对象或两个原始类型是否不相等\n\n\nassertSame\n判断两个对象引用是否指向同一个对象\n\n\nassertNotSame\n判断两个对象引用是否指向不同的对象\n\n\nassertTrue\n判断给定的布尔值是否为 true\n\n\nassertFalse\n判断给定的布尔值是否为 false\n\n\nassertNull\n判断给定的对象引用是否为 null\n\n\nassertNotNull\n判断给定的对象引用是否不为 null\n\n\n超时断言：Assertions.assertTimeout() 为测试方法设置了超时时间\n异常断言：Assertions.assertThrows() 配合函数式编程使用\n快速失败：通过 fail() 方法直接使得测试失败\n监控\n简介\n未来每一个微服务在云上部署以后，我们都需要对其进行监控、追踪、审计、控制等。SpringBoot 就抽取了 Spring Boot Actuator 场景，使得我们每个微服务快速引用即可获得生产级别的应用监控、审计等功能。\n1.x 与 2.x 的不同：\n\n使用\n1234&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;&lt;/dependency&gt;\n访问http://localhost:8080/actuator\n\nSpring Boot Admin\ncodecentric/spring-boot-admin: Admin UI for administration of spring boot applications\nadmin-server:\n\n创建admin-server模块\n导入依赖坐标admin-starter-server\n在引导类上启用监控功能@EnableAdminServer\n\nadmin-client:\n\n\n创建admin-client模块\n\n\n导入依赖坐标admin-starter-client\n\n\n配置相关信息：server地址等\n\n\n启动server和client服务，访问server\n\n\n\n事件与监听\n参考：\n\n强大的Spring Boot启动监听器事件-初始化系统账号密码 - 掘金\nSpringBoot监听器 - 掘金\n\nSpringApplicationEvents 事件类型\n\n\n自定义事件\nSpring 的事件监听最简单使用例子 - 掘金\n","plink":"http://www.chenyuxi.top/spring-boot/"},{"title":"测试第三篇博客","date":"2021-10-17T14:25:03.000Z","date_formatted":{"ll":"2021年10月17日","L":"2021/10/17","MM-DD":"10-17"},"updated":"2021-10-17T06:25:04.019Z","content":"","plink":"http://www.chenyuxi.top/7418c452/"},{"title":"Manjaro kde Installation Note","date":"2021-10-17T14:24:58.000Z","date_formatted":{"ll":"2021年10月17日","L":"2021/10/17","MM-DD":"10-17"},"updated":"2021-10-17T06:26:23.185Z","content":"Manjaro kde Installation Note\n前言\n\n准备折腾一下Win10 + Manjaro kde 双系统，但还未安装就听说坑特别多，特此记录全过程。\n环境：\n\nUEFI + GPT引导方式\n512 ssd + 256 ssd，双硬盘分别安装双系统。\n神舟 TX7-CT5DS\n\n先记录一下Windows下常用软件，方便在安装完之后对照配置Manjaro。\n\n工具\n\nSSTap\nFiddler\nEverything\nuTools\npostman\nToDesk\nSnipaste\nTypora\nDBCHM\nInternet Download Manager\n\n应用\n\n\nFirefox\n\n\nChrome\n\n\nWPS\n\n\nQQ\n\n\nWechat\n\n\n钉钉\n\n\n百度网盘\n\n\nQQ音乐\n\n\n网易云音乐\n\n\n火绒\n\n\n有道云笔记\n\n\n滴答清单\n\n\nPowerShadow 8.5\n\n\nXMind ZEN\n\n\ndraw.io\n\n\nVMware\n\n\nBandicam\n\n\nBindZip\n\n\nPotPlayer\n\n\n有道词典\n\n\n开发\n\nSublime Text3\nVisual Studio Code\nIntelliJ IDEA 2019.2.1\nNavicat Premium 15\n易语言 5.7\n\n环境\n\nJDK 8\nMySQL 5.5\nPython 3\n\n准备工作\n确保是UEFI+GPT启动方式\nLegacy和UEFI指的是系统引导方式。\nLegacy为传统BIOS，UEFI为新式BIOS，MBR和GPT指的是磁盘分区表类型。\n目前主流的是Legacy+MBR， UEFI+GPT这两种组合，\nMBR+BIOS 该退出历史舞台了，\nGPT+UEFI 拥有更好的性能与更高的安全性。\n这里我在磁盘管理看到这块准备装Manjaro的空硬盘是MBR格式的。\n\n于是删除卷之后，右键磁盘-转为GPT磁盘。\n\n最后，新建简单卷-不分配驱动器号或驱动器路径-不要格式化这个卷。\n关闭快速启动\n勾选快速启动可能会因为开机太快而无法进入BIOS。\n参考：关闭方法\n关闭安全启动\nBIOS —&gt; System Configuration —&gt; Boot Options —&gt; Secure Boot —&gt; Disabled\n这一步很重要，否则会出现这种情况：\n\n有些人进入 BIOS 会发现 Secure Boot 这个选项是灰色的，这时你需要先给 BIOS 设一个密码，然后就能关 Secure Boot了。\n原因好像是微软为了垄断，参考：secure boot的作用是什么——为什么安装win+Manjaro需要关闭它\nNVMe协议M.2接口SSD的坑\n\n如果你的ssd是NVMe协议M.2的，需要在进入安装界面之前先进去BIOS里面修改从硬盘的启动形式，把RAID改成AHCI，保存退出，否则进入安装界面你不会看到你的NVMe硬盘，做好这件事其他就都和普通ssd一样了。还需要注意的一点是，修改成AHCI模式之后，重新进入Windows时会有问题，这个时候不要慌，等电脑自动重启第三次的时候，进入安全模式启动Windows，进去之后重启系统，再次进入Windows就不需要安全模式了\n\n暂时没遇到此问题，先留着：https://zhuanlan.zhihu.com/p/114296129\n下载镜像\n官网：https://manjaro.org/download/\n有人说官网下载特别慢，但我是在官网下载的，感觉还可。\n不知道是不是跑的SSR的流量，没注意看。\n备用：清华大学开源镜像网站这个可能会快一点。\n安装系统\n烧录镜像\n下载Rufus\n官网：http://rufus.ie/\n最新版本的Rufus可能无法选择分区类型，可以选择下载低版本\n官网没找到旧版本，我是在这个链接，下载的3.1版本。\n开始刻录\n插入u盘，打开refus。\n选择镜像，设置如下：\n\n其他设置不用管，点击开始。\n提示选择镜像写入模式：\n\n这里一定要选择DD模式，否则无法进入引导。\n刻录之后U盘的可见大小会变小，这个可以恢复\n恢复的方法：\n下载 DiskGenius 先删除U盘所有分区保存更改，然后清除扇区数据（开始清除之后直接取消即可，不用管有什么报错信息），之后格式化。\n直接格式化会失败，必须先清除扇区数据。\n开始安装\nwin10设置-&gt;更新和安全-&gt;恢复-&gt;立即重新启动。\n选择从u盘启动。\n这时电脑重启后会进入manjaro lived。\n安装过程google一搜一大把，基本都是下一步，这里因为仅做个人系统配置笔记，所以不再赘述。\n要注意的有两点\n第一点是进入lived前的列表的显卡驱动选择（free和nofnree）。\n以为我本子独显是NVIDIA，所以这里选择的是nonfree (让系统自动安装合适的闭源驱动)。\n可以参考：\n\n\nCPU\n显卡\n选择\n\n\n\n\nIntel\n无独显\nfree\n\n\nAMD\n无独显\nfree\n\n\nAMD\nNVIDIA\nno free\n\n\nIntel\nAMD\nfree\n\n\nIntel\nNVIDIA\nno free\n\n\n第二点是分区\n\n\n挂载点\n文件系统\n大小\n标记\n备注\n\n\n\n\n\nlinuxswap\n4GiB\nswap\n内存交换空间\n\n\n/boot/efi\nFAT32\n512MiB\nboot\n存放UEFI引导文件\n\n\n/\next4\nthe rest\nroot\n相当于根目录\n\n\n内存交换空间，相当于windows下虚拟内存pagefile.sys，作用是内存不足时用硬盘模拟内存，性能也是可想而知…，现在内存16gb及以上的基本可以不用了，但我这里还是保险起见设置了4g。\n安装完后会进入Manjaro的Grub引导界面，可以选择进入哪一个系统。\n\n\n至此， Manjaro 已安装完成了，但折腾才刚刚开始…\n\n配置系统\n问题记录\n\n部分系统习惯性设置及踩坑记录\n\n触摸板\n设置-输入设备-触摸板-勾选反向滚动\n1暂未解决：触摸板只能在设置里面禁用而无法通过键盘快捷键Fn开关。\n键盘背光无法调节\n1暂未解决\n启动开NumLock\n设置-输入设备-键盘-Plasma启动时Numlock状态-开启\n音频数字红灯\n1暂未解决\n使 Kwin 最高144hz\n这个折腾了很久，一开始以为是显卡驱动的问题，疯狂踩坑，直到找到这篇帖子…\n\n即使显示器本身已正确设置为144Hz，KWin仍拒绝以该刷新率自动运行。它的默认值为慢速60Hz，所以现在您有了一个合成器，它在以144Hz刷新的监视器上以60Hz刷新，这不是一个好的体验，尤其是在帧定时方面。我提交了错误395632，尽管与开发人员进行了一些沟通，但我认为他们从此对错误失去了兴趣并停止了响应。\nEven though the monitor itself gets set properly to 144Hz, KWin refuses to automatically run at that refresh rate. It will default to a slow 60Hz, so now you have a compositor that’s refreshing at 60Hz on a monitor that’s refreshing at 144Hz, which isn’t a good experience, especially in regards to frame timing. I’ve filed bug 395632 and while there was some communication with the devs, I believe they’ve since lost interest in the bug and stopped responding.\n\n**解决方法：**添加MaxFPS=144到~/.config/kwinrc的[Compositing]下。\n参考：https://www.reddit.com/r/kde/comments/brsmqc/gnome_still_handles_highrefresh_rate_monitors/\n时间校正及双系统时间同步\n时间校正：直接在系统时间设置里面开启自动对时。\n双系统时间同步：\n12timedatectl set-local-rtc true暂时没遇到，占位。\n耗电高\n1待进一步验证及解决\n风扇一直转\n1待进一步验证及解决\n安装软件\n选择中国源并更新\n12sudo pacman-mirrors -i -c China -m rankselect -&gt; https://mirrors.ustc.edu.cn/    \n更新系统\n1sudo pacman -Syyu\nyay\n1sudo pacman -Sy yay\n中文输入法\n12345678910111213141516sudo pacman -Sy fcitxsudo pacman -Sy fcitx-configtoolyay fcitx-googlepinyin    错误： Cannot find the strip binary required for object file stripping.     解决方法：因为没安装 fakeroot、binutils 等打包基本工具，所以sudo pacman -S base-devel 装一下。    yay fcitx-qt4添加输入法配置文件sudo nano ~/.xprofile在文件中添加如下内容export GTK_IM_MODULE=fcitxexport QT_IM_MODULE=fcitxexport XMODIFIERS=&quot;@im=fcitx&quot;注销系统\nqv2ary\n123yay qv2ray配置v2ray-core：https://qv2ray.net/getting-started/step2.html配置SSR插件：https://qv2ray.net/plugins/usage.html\ntypora\n1yay typora\nGoogle-Chrome\n1yay -S google-chrome\n网易云音乐\n1yay -S netease-cloud-music\n系统美化\n桌面特效\n\n魔灯\n摆动窗口\n关闭显示桌面动画\n模糊 - 模糊强度60% - 噪点0%\n\nKwin脚本\n下载启用Force Blur ？？？？\nDock\n12345678910软件商店搜索下载 latte-dock-git勾选确定下载布局：https://www.pling.com/p/1399346mcOS-BS-Large.layout.latte.zipmacOS-BS-Extra-Icons.zip\n参考链接\nwin10环境下安装manjaro kde（双系统）- Jaywhenxiang\n","plink":"http://www.chenyuxi.top/Manjaro-kde-Installation-Note/"},{"title":"测试第二篇博客","date":"2021-10-17T14:24:58.000Z","date_formatted":{"ll":"2021年10月17日","L":"2021/10/17","MM-DD":"10-17"},"updated":"2021-10-17T06:26:27.986Z","content":"","plink":"http://www.chenyuxi.top/ca5db6d7/"},{"title":"测试第一篇博客","date":"2021-10-17T14:24:48.000Z","date_formatted":{"ll":"2021年10月17日","L":"2021/10/17","MM-DD":"10-17"},"updated":"2021-10-17T06:24:48.829Z","content":"","plink":"http://www.chenyuxi.top/880def98/"},{"title":"Hello World","date":"2021-10-16T19:37:26.759Z","date_formatted":{"ll":"2021年10月16日","L":"2021/10/16","MM-DD":"10-16"},"updated":"2021-10-16T17:09:32.519Z","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.:rocket:\nQuick Start\nCreate a new post\n1$ hexo new &quot;My New Post&quot;\nMore info: Writing\nRun server\n1$ hexo server\nMore info: Server\nGenerate static files\n1$ hexo generate\nMore info: Generating\nDeploy to remote sites\n1$ hexo deploy\nMore info: Deployment\n","plink":"http://www.chenyuxi.top/4a17b156/"}]